/* NetHack 3.7 sfdata.c */
/* Copyright (c) NetHack Development Team 2019.                   */
/* NetHack may be freely redistributed.  See license for details. */

/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE!          */

#include "hack.h"
#include "artifact.h"
#include "func_tab.h"
#include "lev.h"
#include "integer.h"
#include "wintype.h"
#include "sfproto.h"

#define NHTYPE_SIMPLE    1
#define NHTYPE_COMPLEX   2
struct nhdatatypes_t {
    unsigned int dtclass;
    char *dtype;
    size_t dtsize;
};

static uint8_t bitfield = 0;

void
sfo_align(nhfp, d_align, myparent, myname, cnt)
NHFILE *nhfp;
struct align *d_align;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "align";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "align", 1);

    sfo_aligntyp(nhfp, &d_align->type, parent, "type", 1);       /* (aligntyp) */
    sfo_int(nhfp, &d_align->record, parent, "record", 1);        /* (int) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "align", 1);
}

void
sfo_attribs(nhfp, d_attribs, myparent, myname, cnt)
NHFILE *nhfp;
struct attribs *d_attribs;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "attribs";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "attribs", 1);

    sfo_schar(nhfp, d_attribs->a, parent, "a", A_MAX);           /* (schar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "attribs", 1);
}

void
sfo_bill_x(nhfp, d_bill_x, myparent, myname, cnt)
NHFILE *nhfp;
struct bill_x *d_bill_x;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "bill_x";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "bill_x", 1);

    sfo_unsigned(nhfp, &d_bill_x->bo_id, parent, "bo_id", 1);    /* (unsigned) */
    sfo_boolean(nhfp, &d_bill_x->useup, parent, "useup", 1);     /* (boolean) */
    sfo_long(nhfp, &d_bill_x->price, parent, "price", 1);        /* (long) */
    sfo_long(nhfp, &d_bill_x->bquan, parent, "bquan", 1);        /* (long) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "bill_x", 1);
}

void
sfo_book_info(nhfp, d_book_info, myparent, myname, cnt)
NHFILE *nhfp;
struct book_info *d_book_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "book_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "book_info", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_book_info->book, parent, "book", 1);/* (struct obj *) */
    sfo_unsigned(nhfp, &d_book_info->o_id, parent, "o_id", 1);   /* (unsigned) */
    sfo_schar(nhfp, &d_book_info->delay, parent, "delay", 1);    /* (schar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "book_info", 1);
}

void
sfo_branch(nhfp, d_branch, myparent, myname, cnt)
NHFILE *nhfp;
struct branch *d_branch;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "branch";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "branch", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_branch->next, parent, "next", 1);/* (struct branch *) */
    sfo_int(nhfp, &d_branch->id, parent, "id", 1);               /* (int) */
    sfo_int(nhfp, &d_branch->type, parent, "type", 1);           /* (int) */
    sfo_d_level(nhfp, &d_branch->end1, parent, "end1", 1);       /* (d_level) */
    sfo_d_level(nhfp, &d_branch->end2, parent, "end2", 1);       /* (d_level) */
    sfo_boolean(nhfp, &d_branch->end1_up, parent, "end1_up", 1); /* (boolean) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "branch", 1);
}

void
sfo_bubble(nhfp, d_bubble, myparent, myname, cnt)
NHFILE *nhfp;
struct bubble *d_bubble;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "bubble";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "bubble", 1);

    sfo_xchar(nhfp, &d_bubble->x, parent, "x", 1);               /* (xchar) */
    sfo_xchar(nhfp, &d_bubble->y, parent, "y", 1);               /* (xchar) */
    sfo_schar(nhfp, &d_bubble->dx, parent, "dx", 1);             /* (schar) */
    sfo_schar(nhfp, &d_bubble->dy, parent, "dy", 1);             /* (schar) */
    sfo_uchar(nhfp, d_bubble->bm, parent, "bm", MAX_BMASK + 2);  /* (uchar) */
    sfo_genericptr(nhfp, (genericptr_t) &d_bubble->prev, parent, "prev", 1);/* (struct bubble *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_bubble->next, parent, "next", 1);/* (struct bubble *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_bubble->cons, parent, "cons", 1);/* (struct container *) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "bubble", 1);
}

void
sfo_cemetery(nhfp, d_cemetery, myparent, myname, cnt)
NHFILE *nhfp;
struct cemetery *d_cemetery;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "cemetery";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "cemetery", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_cemetery->next, parent, "next", 1);/* (struct cemetery *) */
    sfo_char(nhfp, d_cemetery->who, parent, "who", PL_NSIZ + 4 * (1 + 3) + 1);/* (char) */
    sfo_char(nhfp, d_cemetery->how, parent, "how", 100 + 1);     /* (char) */
    sfo_char(nhfp, d_cemetery->when, parent, "when", 4 + 2 + 2 + 2 + 2 + 2 + 1);/* (char) */
    sfo_schar(nhfp, &d_cemetery->frpx, parent, "frpx", 1);       /* (schar) */
    sfo_schar(nhfp, &d_cemetery->frpy, parent, "frpy", 1);       /* (schar) */
    sfo_boolean(nhfp, &d_cemetery->bonesknown, parent, "bonesknown", 1);/* (boolean) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "cemetery", 1);
}

void
sfo_context_info(nhfp, d_context_info, myparent, myname, cnt)
NHFILE *nhfp;
struct context_info *d_context_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "context_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "context_info", 1);

    sfo_unsigned(nhfp, &d_context_info->ident, parent, "ident", 1);/* (unsigned) */
    sfo_unsigned(nhfp, &d_context_info->no_of_wizards, parent, "no_of_wizards", 1);/* (unsigned) */
    sfo_unsigned(nhfp, &d_context_info->run, parent, "run", 1);  /* (unsigned) */
    sfo_unsigned(nhfp, &d_context_info->startingpet_mid, parent, "startingpet_mid", 1);/* (unsigned) */
    sfo_int(nhfp, &d_context_info->current_fruit, parent, "current_fruit", 1);/* (int) */
    sfo_int(nhfp, &d_context_info->warnlevel, parent, "warnlevel", 1);/* (int) */
    sfo_int(nhfp, &d_context_info->rndencode, parent, "rndencode", 1);/* (int) */
    sfo_long(nhfp, &d_context_info->next_attrib_check, parent, "next_attrib_check", 1);/* (long) */
    sfo_long(nhfp, &d_context_info->stethoscope_move, parent, "stethoscope_move", 1);/* (long) */
    sfo_short(nhfp, &d_context_info->stethoscope_movement, parent, "stethoscope_movement", 1);/* (short) */
    sfo_boolean(nhfp, &d_context_info->travel, parent, "travel", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_context_info->travel1, parent, "travel1", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_context_info->forcefight, parent, "forcefight", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_context_info->nopick, parent, "nopick", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_context_info->made_amulet, parent, "made_amulet", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_context_info->mon_moving, parent, "mon_moving", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_context_info->move, parent, "move", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_context_info->mv, parent, "mv", 1);     /* (boolean) */
    sfo_boolean(nhfp, &d_context_info->bypasses, parent, "bypasses", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_context_info->botl, parent, "botl", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_context_info->botlx, parent, "botlx", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_context_info->door_opened, parent, "door_opened", 1);/* (boolean) */
    sfo_dig_info(nhfp, &d_context_info->digging, parent, "digging", 1);/* (dig_info) */
    sfo_victual_info(nhfp, &d_context_info->victual, parent, "victual", 1);/* (victual_info) */
    sfo_tin_info(nhfp, &d_context_info->tin, parent, "tin", 1);  /* (tin_info) */
    sfo_book_info(nhfp, &d_context_info->spbook, parent, "spbook", 1);/* (book_info) */
    sfo_takeoff_info(nhfp, &d_context_info->takeoff, parent, "takeoff", 1);/* (takeoff_info) */
    sfo_warntype_info(nhfp, &d_context_info->warntype, parent, "warntype", 1);/* (warntype_info) */
    sfo_polearm_info(nhfp, &d_context_info->polearm, parent, "polearm", 1);/* (polearm_info) */
    sfo_obj_split(nhfp, &d_context_info->objsplit, parent, "objsplit", 1);/* (obj_split) */
    sfo_tribute_info(nhfp, &d_context_info->tribute, parent, "tribute", 1);/* (tribute_info) */
    sfo_novel_tracking(nhfp, &d_context_info->novel, parent, "novel", 1);/* (novel_tracking) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "context_info", 1);
}

void
sfo_d_flags(nhfp, d_d_flags, myparent, myname, cnt)
NHFILE *nhfp;
struct d_flags *d_d_flags;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "d_flags";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "d_flags", 1);

    bitfield = d_d_flags->town;                                  /* (Bitfield(town, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "town",  1);
    bitfield = d_d_flags->hellish;                               /* (Bitfield(hellish, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "hellish",  1);
    bitfield = d_d_flags->maze_like;                             /* (Bitfield(maze_like, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "maze_like",  1);
    bitfield = d_d_flags->rogue_like;                            /* (Bitfield(rogue_like, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "rogue_like",  1);
    bitfield = d_d_flags->align;                                 /* (Bitfield(align, 3)) */
    sfo_bitfield(nhfp, &bitfield, parent, "align",  3);
    bitfield = d_d_flags->unused;                                /* (Bitfield(unused, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "unused",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "d_flags", 1);
}

void
sfo_d_level(nhfp, d_d_level, myparent, myname, cnt)
NHFILE *nhfp;
struct d_level *d_d_level;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "d_level";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "d_level", 1);

    sfo_xchar(nhfp, &d_d_level->dnum, parent, "dnum", 1);        /* (xchar) */
    sfo_xchar(nhfp, &d_d_level->dlevel, parent, "dlevel", 1);    /* (xchar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "d_level", 1);
}

void
sfo_damage(nhfp, d_damage, myparent, myname, cnt)
NHFILE *nhfp;
struct damage *d_damage;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "damage";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "damage", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_damage->next, parent, "next", 1);/* (struct damage *) */
    sfo_long(nhfp, &d_damage->when, parent, "when", 1);          /* (long) */
    sfo_long(nhfp, &d_damage->cost, parent, "cost", 1);          /* (long) */
    sfo_nhcoord(nhfp, &d_damage->place, parent, "place", 1);     /* (nhcoord) */
    sfo_schar(nhfp, &d_damage->typ, parent, "typ", 1);           /* (schar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "damage", 1);
}

void
sfo_dest_area(nhfp, d_dest_area, myparent, myname, cnt)
NHFILE *nhfp;
struct dest_area *d_dest_area;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "dest_area";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "dest_area", 1);

    sfo_xchar(nhfp, &d_dest_area->lx, parent, "lx", 1);          /* (xchar) */
    sfo_xchar(nhfp, &d_dest_area->ly, parent, "ly", 1);          /* (xchar) */
    sfo_xchar(nhfp, &d_dest_area->hx, parent, "hx", 1);          /* (xchar) */
    sfo_xchar(nhfp, &d_dest_area->hy, parent, "hy", 1);          /* (xchar) */
    sfo_xchar(nhfp, &d_dest_area->nlx, parent, "nlx", 1);        /* (xchar) */
    sfo_xchar(nhfp, &d_dest_area->nly, parent, "nly", 1);        /* (xchar) */
    sfo_xchar(nhfp, &d_dest_area->nhx, parent, "nhx", 1);        /* (xchar) */
    sfo_xchar(nhfp, &d_dest_area->nhy, parent, "nhy", 1);        /* (xchar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "dest_area", 1);
}

void
sfo_dgn_topology(nhfp, d_dgn_topology, myparent, myname, cnt)
NHFILE *nhfp;
struct dgn_topology *d_dgn_topology;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "dgn_topology";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "dgn_topology", 1);

    sfo_d_level(nhfp, &d_dgn_topology->d_oracle_level, parent, "d_oracle_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_bigroom_level, parent, "d_bigroom_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_rogue_level, parent, "d_rogue_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_medusa_level, parent, "d_medusa_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_stronghold_level, parent, "d_stronghold_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_valley_level, parent, "d_valley_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_wiz1_level, parent, "d_wiz1_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_wiz2_level, parent, "d_wiz2_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_wiz3_level, parent, "d_wiz3_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_juiblex_level, parent, "d_juiblex_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_orcus_level, parent, "d_orcus_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_baalzebub_level, parent, "d_baalzebub_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_asmodeus_level, parent, "d_asmodeus_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_portal_level, parent, "d_portal_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_sanctum_level, parent, "d_sanctum_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_earth_level, parent, "d_earth_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_water_level, parent, "d_water_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_fire_level, parent, "d_fire_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_air_level, parent, "d_air_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_astral_level, parent, "d_astral_level", 1);/* (d_level) */
    sfo_xchar(nhfp, &d_dgn_topology->d_tower_dnum, parent, "d_tower_dnum", 1);/* (xchar) */
    sfo_xchar(nhfp, &d_dgn_topology->d_sokoban_dnum, parent, "d_sokoban_dnum", 1);/* (xchar) */
    sfo_xchar(nhfp, &d_dgn_topology->d_mines_dnum, parent, "d_mines_dnum", 1);/* (xchar) */
    sfo_xchar(nhfp, &d_dgn_topology->d_quest_dnum, parent, "d_quest_dnum", 1);/* (xchar) */
    sfo_d_level(nhfp, &d_dgn_topology->d_qstart_level, parent, "d_qstart_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_qlocate_level, parent, "d_qlocate_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_nemesis_level, parent, "d_nemesis_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_knox_level, parent, "d_knox_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_mineend_level, parent, "d_mineend_level", 1);/* (d_level) */
    sfo_d_level(nhfp, &d_dgn_topology->d_sokoend_level, parent, "d_sokoend_level", 1);/* (d_level) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "dgn_topology", 1);
}

void
sfo_dig_info(nhfp, d_dig_info, myparent, myname, cnt)
NHFILE *nhfp;
struct dig_info *d_dig_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "dig_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "dig_info", 1);

    sfo_int(nhfp, &d_dig_info->effort, parent, "effort", 1);     /* (int) */
    sfo_d_level(nhfp, &d_dig_info->level, parent, "level", 1);   /* (d_level) */
    sfo_nhcoord(nhfp, &d_dig_info->pos, parent, "pos", 1);       /* (nhcoord) */
    sfo_long(nhfp, &d_dig_info->lastdigtime, parent, "lastdigtime", 1);/* (long) */
    sfo_boolean(nhfp, &d_dig_info->down, parent, "down", 1);     /* (boolean) */
    sfo_boolean(nhfp, &d_dig_info->chew, parent, "chew", 1);     /* (boolean) */
    sfo_boolean(nhfp, &d_dig_info->warned, parent, "warned", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_dig_info->quiet, parent, "quiet", 1);   /* (boolean) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "dig_info", 1);
}

void
sfo_dungeon(nhfp, d_dungeon, myparent, myname, cnt)
NHFILE *nhfp;
struct dungeon *d_dungeon;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "dungeon";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "dungeon", 1);

    sfo_char(nhfp, d_dungeon->dname, parent, "dname", 24);       /* (char) */
    sfo_char(nhfp, d_dungeon->proto, parent, "proto", 15);       /* (char) */
    sfo_char(nhfp, &d_dungeon->boneid, parent, "boneid", 1);     /* (char) */
    sfo_d_flags(nhfp, &d_dungeon->flags, parent, "flags", 1);    /* (d_flags) */
    sfo_xchar(nhfp, &d_dungeon->entry_lev, parent, "entry_lev", 1);/* (xchar) */
    sfo_xchar(nhfp, &d_dungeon->num_dunlevs, parent, "num_dunlevs", 1);/* (xchar) */
    sfo_xchar(nhfp, &d_dungeon->dunlev_ureached, parent, "dunlev_ureached", 1);/* (xchar) */
    sfo_int(nhfp, &d_dungeon->ledger_start, parent, "ledger_start", 1);/* (int) */
    sfo_int(nhfp, &d_dungeon->depth_start, parent, "depth_start", 1);/* (int) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "dungeon", 1);
}

void
sfo_edog(nhfp, d_edog, myparent, myname, cnt)
NHFILE *nhfp;
struct edog *d_edog;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "edog";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "edog", 1);

    sfo_long(nhfp, &d_edog->droptime, parent, "droptime", 1);    /* (long) */
    sfo_unsigned(nhfp, &d_edog->dropdist, parent, "dropdist", 1);/* (unsigned) */
    sfo_int(nhfp, &d_edog->apport, parent, "apport", 1);         /* (int) */
    sfo_long(nhfp, &d_edog->whistletime, parent, "whistletime", 1);/* (long) */
    sfo_long(nhfp, &d_edog->hungrytime, parent, "hungrytime", 1);/* (long) */
    sfo_nhcoord(nhfp, &d_edog->ogoal, parent, "ogoal", 1);       /* (nhcoord) */
    sfo_int(nhfp, &d_edog->abuse, parent, "abuse", 1);           /* (int) */
    sfo_int(nhfp, &d_edog->revivals, parent, "revivals", 1);     /* (int) */
    sfo_int(nhfp, &d_edog->mhpmax_penalty, parent, "mhpmax_penalty", 1);/* (int) */
    bitfield = d_edog->killed_by_u;                              /* (Bitfield(killed_by_u, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "killed_by_u",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "edog", 1);
}

void
sfo_egd(nhfp, d_egd, myparent, myname, cnt)
NHFILE *nhfp;
struct egd *d_egd;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "egd";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "egd", 1);

    sfo_int(nhfp, &d_egd->fcbeg, parent, "fcbeg", 1);            /* (int) */
    sfo_int(nhfp, &d_egd->fcend, parent, "fcend", 1);            /* (int) */
    sfo_int(nhfp, &d_egd->vroom, parent, "vroom", 1);            /* (int) */
    sfo_xchar(nhfp, &d_egd->gdx, parent, "gdx", 1);              /* (xchar) */
    sfo_xchar(nhfp, &d_egd->gdy, parent, "gdy", 1);              /* (xchar) */
    sfo_xchar(nhfp, &d_egd->ogx, parent, "ogx", 1);              /* (xchar) */
    sfo_xchar(nhfp, &d_egd->ogy, parent, "ogy", 1);              /* (xchar) */
    sfo_d_level(nhfp, &d_egd->gdlevel, parent, "gdlevel", 1);    /* (d_level) */
    sfo_xchar(nhfp, &d_egd->warncnt, parent, "warncnt", 1);      /* (xchar) */
    bitfield = d_egd->gddone;                                    /* (Bitfield(gddone, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "gddone",  1);
    bitfield = d_egd->witness;                                   /* (Bitfield(witness, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "witness",  2);
    bitfield = d_egd->unused;                                    /* (Bitfield(unused, 5)) */
    sfo_bitfield(nhfp, &bitfield, parent, "unused",  5);
    for (i = 0; i < FCSIZ; ++i)
        sfo_fakecorridor(nhfp, &d_egd->fakecorr[i], parent, "fakecorr", 1);/* (fakecorridor) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "egd", 1);
}

void
sfo_emin(nhfp, d_emin, myparent, myname, cnt)
NHFILE *nhfp;
struct emin *d_emin;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "emin";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "emin", 1);

    sfo_aligntyp(nhfp, &d_emin->min_align, parent, "min_align", 1);/* (aligntyp) */
    sfo_boolean(nhfp, &d_emin->renegade, parent, "renegade", 1); /* (boolean) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "emin", 1);
}

void
sfo_engr(nhfp, d_engr, myparent, myname, cnt)
NHFILE *nhfp;
struct engr *d_engr;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "engr";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "engr", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_engr->nxt_engr, parent, "nxt_engr", 1);/* (struct engr *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_engr->engr_txt, parent, "engr_txt", 1);/* (char *) */
    sfo_xchar(nhfp, &d_engr->engr_x, parent, "engr_x", 1);       /* (xchar) */
    sfo_xchar(nhfp, &d_engr->engr_y, parent, "engr_y", 1);       /* (xchar) */
    sfo_unsigned(nhfp, &d_engr->engr_lth, parent, "engr_lth", 1);/* (unsigned) */
    sfo_long(nhfp, &d_engr->engr_time, parent, "engr_time", 1);  /* (long) */
    sfo_xchar(nhfp, &d_engr->engr_type, parent, "engr_type", 1); /* (xchar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "engr", 1);
}

void
sfo_epri(nhfp, d_epri, myparent, myname, cnt)
NHFILE *nhfp;
struct epri *d_epri;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "epri";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "epri", 1);

    sfo_aligntyp(nhfp, &d_epri->shralign, parent, "shralign", 1);/* (aligntyp) */
    sfo_schar(nhfp, &d_epri->shroom, parent, "shroom", 1);       /* (schar) */
    sfo_nhcoord(nhfp, &d_epri->shrpos, parent, "shrpos", 1);     /* (nhcoord) */
    sfo_d_level(nhfp, &d_epri->shrlevel, parent, "shrlevel", 1); /* (d_level) */
    sfo_long(nhfp, &d_epri->intone_time, parent, "intone_time", 1);/* (long) */
    sfo_long(nhfp, &d_epri->enter_time, parent, "enter_time", 1);/* (long) */
    sfo_long(nhfp, &d_epri->hostile_time, parent, "hostile_time", 1);/* (long) */
    sfo_long(nhfp, &d_epri->peaceful_time, parent, "peaceful_time", 1);/* (long) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "epri", 1);
}

void
sfo_eshk(nhfp, d_eshk, myparent, myname, cnt)
NHFILE *nhfp;
struct eshk *d_eshk;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "eshk";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "eshk", 1);

    sfo_long(nhfp, &d_eshk->robbed, parent, "robbed", 1);        /* (long) */
    sfo_long(nhfp, &d_eshk->credit, parent, "credit", 1);        /* (long) */
    sfo_long(nhfp, &d_eshk->debit, parent, "debit", 1);          /* (long) */
    sfo_long(nhfp, &d_eshk->loan, parent, "loan", 1);            /* (long) */
    sfo_int(nhfp, &d_eshk->shoptype, parent, "shoptype", 1);     /* (int) */
    sfo_schar(nhfp, &d_eshk->shoproom, parent, "shoproom", 1);   /* (schar) */
    sfo_schar(nhfp, &d_eshk->unused, parent, "unused", 1);       /* (schar) */
    sfo_boolean(nhfp, &d_eshk->following, parent, "following", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_eshk->surcharge, parent, "surcharge", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_eshk->dismiss_kops, parent, "dismiss_kops", 1);/* (boolean) */
    sfo_nhcoord(nhfp, &d_eshk->shk, parent, "shk", 1);           /* (nhcoord) */
    sfo_nhcoord(nhfp, &d_eshk->shd, parent, "shd", 1);           /* (nhcoord) */
    sfo_d_level(nhfp, &d_eshk->shoplevel, parent, "shoplevel", 1);/* (d_level) */
    sfo_int(nhfp, &d_eshk->billct, parent, "billct", 1);         /* (int) */
    for (i = 0; i < BILLSZ; ++i)
        sfo_bill_x(nhfp, &d_eshk->bill[i], parent, "bill", 1);   /* (bill_x) */
    sfo_genericptr(nhfp, (genericptr_t) &d_eshk->bill_p, parent, "bill_p", 1);/* (struct bill_x *) */
    sfo_int(nhfp, &d_eshk->visitct, parent, "visitct", 1);       /* (int) */
    sfo_char(nhfp, d_eshk->customer, parent, "customer", PL_NSIZ);/* (char) */
    sfo_char(nhfp, d_eshk->shknam, parent, "shknam", PL_NSIZ);   /* (char) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "eshk", 1);
}

void
sfo_fakecorridor(nhfp, d_fakecorridor, myparent, myname, cnt)
NHFILE *nhfp;
struct fakecorridor *d_fakecorridor;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "fakecorridor";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "fakecorridor", 1);

    sfo_xchar(nhfp, &d_fakecorridor->fx, parent, "fx", 1);       /* (xchar) */
    sfo_xchar(nhfp, &d_fakecorridor->fy, parent, "fy", 1);       /* (xchar) */
    sfo_xchar(nhfp, &d_fakecorridor->ftyp, parent, "ftyp", 1);   /* (xchar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "fakecorridor", 1);
}

void
sfo_fe(nhfp, d_fe, myparent, myname, cnt)
NHFILE *nhfp;
struct fe *d_fe;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "fe";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "fe", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_fe->next, parent, "next", 1);/* (struct fe *) */
    sfo_long(nhfp, &d_fe->timeout, parent, "timeout", 1);        /* (long) */
    sfo_ulong(nhfp, &d_fe->tid, parent, "tid", 1);               /* (unsigned long) */
    sfo_short(nhfp, &d_fe->kind, parent, "kind", 1);             /* (short) */
    sfo_short(nhfp, &d_fe->func_index, parent, "func_index", 1); /* (short) */
    sfo_any(nhfp, &d_fe->arg, parent, "arg", 1);                 /* (any) */
    bitfield = d_fe->needs_fixup;                                /* (Bitfield(needs_fixup, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "needs_fixup",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "fe", 1);
}

void
sfo_flag(nhfp, d_flag, myparent, myname, cnt)
NHFILE *nhfp;
struct flag *d_flag;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "flag";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "flag", 1);

    sfo_boolean(nhfp, &d_flag->acoustics, parent, "acoustics", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->autodig, parent, "autodig", 1);   /* (boolean) */
    sfo_boolean(nhfp, &d_flag->autoquiver, parent, "autoquiver", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->autoopen, parent, "autoopen", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_flag->beginner, parent, "beginner", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_flag->biff, parent, "biff", 1);         /* (boolean) */
    sfo_boolean(nhfp, &d_flag->bones, parent, "bones", 1);       /* (boolean) */
    sfo_boolean(nhfp, &d_flag->confirm, parent, "confirm", 1);   /* (boolean) */
    sfo_boolean(nhfp, &d_flag->dark_room, parent, "dark_room", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->debug, parent, "debug", 1);       /* (boolean) */
    sfo_boolean(nhfp, &d_flag->end_own, parent, "end_own", 1);   /* (boolean) */
    sfo_boolean(nhfp, &d_flag->explore, parent, "explore", 1);   /* (boolean) */
    sfo_boolean(nhfp, &d_flag->female, parent, "female", 1);     /* (boolean) */
    sfo_boolean(nhfp, &d_flag->friday13, parent, "friday13", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_flag->help, parent, "help", 1);         /* (boolean) */
    sfo_boolean(nhfp, &d_flag->ignintr, parent, "ignintr", 1);   /* (boolean) */
    sfo_boolean(nhfp, &d_flag->ins_chkpt, parent, "ins_chkpt", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->invlet_constant, parent, "invlet_constant", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->legacy, parent, "legacy", 1);     /* (boolean) */
    sfo_boolean(nhfp, &d_flag->lit_corridor, parent, "lit_corridor", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->nap, parent, "nap", 1);           /* (boolean) */
    sfo_boolean(nhfp, &d_flag->null, parent, "null", 1);         /* (boolean) */
    sfo_boolean(nhfp, &d_flag->p__obsolete, parent, "p__obsolete", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->pickup, parent, "pickup", 1);     /* (boolean) */
    sfo_boolean(nhfp, &d_flag->pickup_thrown, parent, "pickup_thrown", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->pushweapon, parent, "pushweapon", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->rest_on_space, parent, "rest_on_space", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->safe_dog, parent, "safe_dog", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_flag->showexp, parent, "showexp", 1);   /* (boolean) */
    sfo_boolean(nhfp, &d_flag->showscore, parent, "showscore", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->silent, parent, "silent", 1);     /* (boolean) */
    sfo_boolean(nhfp, &d_flag->sortpack, parent, "sortpack", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_flag->sparkle, parent, "sparkle", 1);   /* (boolean) */
    sfo_boolean(nhfp, &d_flag->standout, parent, "standout", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_flag->time, parent, "time", 1);         /* (boolean) */
    sfo_boolean(nhfp, &d_flag->tombstone, parent, "tombstone", 1);/* (boolean) */
    sfo_boolean(nhfp, &d_flag->verbose, parent, "verbose", 1);   /* (boolean) */
    sfo_int(nhfp, &d_flag->end_top, parent, "end_top", 1);       /* (int) */
    sfo_int(nhfp, &d_flag->end_around, parent, "end_around", 1); /* (int) */
    sfo_unsigned(nhfp, &d_flag->moonphase, parent, "moonphase", 1);/* (unsigned) */
    sfo_ulong(nhfp, &d_flag->suppress_alert, parent, "suppress_alert", 1);/* (unsigned long) */
    sfo_unsigned(nhfp, &d_flag->paranoia_bits, parent, "paranoia_bits", 1);/* (unsigned) */
    sfo_int(nhfp, &d_flag->pickup_burden, parent, "pickup_burden", 1);/* (int) */
    sfo_int(nhfp, &d_flag->pile_limit, parent, "pile_limit", 1); /* (int) */
    sfo_char(nhfp, &d_flag->sortloot, parent, "sortloot", 1);    /* (char) */
    sfo_char(nhfp, d_flag->inv_order, parent, "inv_order", MAXOCLASSES);/* (char) */
    sfo_char(nhfp, d_flag->pickup_types, parent, "pickup_types", MAXOCLASSES);/* (char) */
    sfo_char(nhfp, d_flag->end_disclose, parent, "end_disclose", NUM_DISCLOSURE_OPTIONS + 1);/* (char) */
    sfo_char(nhfp, &d_flag->menu_style, parent, "menu_style", 1);/* (char) */
    sfo_boolean(nhfp, &d_flag->made_fruit, parent, "made_fruit", 1);/* (boolean) */
    sfo_int(nhfp, &d_flag->initrole, parent, "initrole", 1);     /* (int) */
    sfo_int(nhfp, &d_flag->initrace, parent, "initrace", 1);     /* (int) */
    sfo_int(nhfp, &d_flag->initgend, parent, "initgend", 1);     /* (int) */
    sfo_int(nhfp, &d_flag->initalign, parent, "initalign", 1);   /* (int) */
    sfo_int(nhfp, &d_flag->randomall, parent, "randomall", 1);   /* (int) */
    sfo_int(nhfp, &d_flag->pantheon, parent, "pantheon", 1);     /* (int) */
    sfo_boolean(nhfp, &d_flag->lootabc, parent, "lootabc", 1);   /* (boolean) */
    sfo_boolean(nhfp, &d_flag->showrace, parent, "showrace", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_flag->travelcmd, parent, "travelcmd", 1);/* (boolean) */
    sfo_int(nhfp, &d_flag->runmode, parent, "runmode", 1);       /* (int) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "flag", 1);
}

void
sfo_fruit(nhfp, d_fruit, myparent, myname, cnt)
NHFILE *nhfp;
struct fruit *d_fruit;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "fruit";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "fruit", 1);

    sfo_char(nhfp, d_fruit->fname, parent, "fname", PL_FSIZ);    /* (char) */
    sfo_int(nhfp, &d_fruit->fid, parent, "fid", 1);              /* (int) */
    sfo_genericptr(nhfp, (genericptr_t) &d_fruit->nextf, parent, "nextf", 1);/* (struct fruit *) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "fruit", 1);
}

void
sfo_kinfo(nhfp, d_kinfo, myparent, myname, cnt)
NHFILE *nhfp;
struct kinfo *d_kinfo;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "kinfo";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "kinfo", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_kinfo->next, parent, "next", 1);/* (struct kinfo *) */
    sfo_int(nhfp, &d_kinfo->id, parent, "id", 1);                /* (int) */
    sfo_int(nhfp, &d_kinfo->format, parent, "format", 1);        /* (int) */
    sfo_char(nhfp, d_kinfo->name, parent, "name", BUFSZ);        /* (char) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "kinfo", 1);
}

void
sfo_levelflags(nhfp, d_levelflags, myparent, myname, cnt)
NHFILE *nhfp;
struct levelflags *d_levelflags;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "levelflags";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "levelflags", 1);

    sfo_uchar(nhfp, &d_levelflags->nfountains, parent, "nfountains", 1);/* (uchar) */
    sfo_uchar(nhfp, &d_levelflags->nsinks, parent, "nsinks", 1); /* (uchar) */
    bitfield = d_levelflags->has_shop;                           /* (Bitfield(has_shop, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_shop",  1);
    bitfield = d_levelflags->has_vault;                          /* (Bitfield(has_vault, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_vault",  1);
    bitfield = d_levelflags->has_zoo;                            /* (Bitfield(has_zoo, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_zoo",  1);
    bitfield = d_levelflags->has_court;                          /* (Bitfield(has_court, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_court",  1);
    bitfield = d_levelflags->has_morgue;                         /* (Bitfield(has_morgue, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_morgue",  1);
    bitfield = d_levelflags->has_beehive;                        /* (Bitfield(has_beehive, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_beehive",  1);
    bitfield = d_levelflags->has_barracks;                       /* (Bitfield(has_barracks, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_barracks",  1);
    bitfield = d_levelflags->has_temple;                         /* (Bitfield(has_temple, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_temple",  1);
    bitfield = d_levelflags->has_swamp;                          /* (Bitfield(has_swamp, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "has_swamp",  1);
    bitfield = d_levelflags->noteleport;                         /* (Bitfield(noteleport, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "noteleport",  1);
    bitfield = d_levelflags->hardfloor;                          /* (Bitfield(hardfloor, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "hardfloor",  1);
    bitfield = d_levelflags->nommap;                             /* (Bitfield(nommap, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "nommap",  1);
    bitfield = d_levelflags->hero_memory;                        /* (Bitfield(hero_memory, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "hero_memory",  1);
    bitfield = d_levelflags->shortsighted;                       /* (Bitfield(shortsighted, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "shortsighted",  1);
    bitfield = d_levelflags->graveyard;                          /* (Bitfield(graveyard, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "graveyard",  1);
    bitfield = d_levelflags->sokoban_rules;                      /* (Bitfield(sokoban_rules, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "sokoban_rules",  1);
    bitfield = d_levelflags->is_maze_lev;                        /* (Bitfield(is_maze_lev, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "is_maze_lev",  1);
    bitfield = d_levelflags->is_cavernous_lev;                   /* (Bitfield(is_cavernous_lev, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "is_cavernous_lev",  1);
    bitfield = d_levelflags->arboreal;                           /* (Bitfield(arboreal, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "arboreal",  1);
    bitfield = d_levelflags->wizard_bones;                       /* (Bitfield(wizard_bones, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "wizard_bones",  1);
    bitfield = d_levelflags->corrmaze;                           /* (Bitfield(corrmaze, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "corrmaze",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "levelflags", 1);
}

void
sfo_linfo(nhfp, d_linfo, myparent, myname, cnt)
NHFILE *nhfp;
struct linfo *d_linfo;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "linfo";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "linfo", 1);

    sfo_uchar(nhfp, &d_linfo->flags, parent, "flags", 1);        /* (unsigned char) */
#ifdef MFLOPPY
    sfo_int(nhfp, &d_linfo->where, parent, "where", 1);          /* (int) */
    sfo_long(nhfp, &d_linfo->time, parent, "time", 1);           /* (long) */
    sfo_long(nhfp, &d_linfo->size, parent, "size", 1);           /* (long) */
#endif /*MFLOPPY*/

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "linfo", 1);
}

void
sfo_ls_t(nhfp, d_ls_t, myparent, myname, cnt)
NHFILE *nhfp;
struct ls_t *d_ls_t;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "ls_t";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "ls_t", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_ls_t->next, parent, "next", 1);/* (struct ls_t *) */
    sfo_xchar(nhfp, &d_ls_t->x, parent, "x", 1);                 /* (xchar) */
    sfo_xchar(nhfp, &d_ls_t->y, parent, "y", 1);                 /* (xchar) */
    sfo_short(nhfp, &d_ls_t->range, parent, "range", 1);         /* (short) */
    sfo_short(nhfp, &d_ls_t->flags, parent, "flags", 1);         /* (short) */
    sfo_short(nhfp, &d_ls_t->type, parent, "type", 1);           /* (short) */
    sfo_any(nhfp, &d_ls_t->id, parent, "id", 1);                 /* (any) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "ls_t", 1);
}

void
sfo_mapseen_feat(nhfp, d_mapseen_feat, myparent, myname, cnt)
NHFILE *nhfp;
struct mapseen_feat *d_mapseen_feat;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mapseen_feat";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "mapseen_feat", 1);

    bitfield = d_mapseen_feat->nfount;                           /* (Bitfield(nfount, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "nfount",  2);
    bitfield = d_mapseen_feat->nsink;                            /* (Bitfield(nsink, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "nsink",  2);
    bitfield = d_mapseen_feat->naltar;                           /* (Bitfield(naltar, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "naltar",  2);
    bitfield = d_mapseen_feat->nthrone;                          /* (Bitfield(nthrone, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "nthrone",  2);
    bitfield = d_mapseen_feat->ngrave;                           /* (Bitfield(ngrave, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ngrave",  2);
    bitfield = d_mapseen_feat->ntree;                            /* (Bitfield(ntree, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ntree",  2);
    bitfield = d_mapseen_feat->water;                            /* (Bitfield(water, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "water",  2);
    bitfield = d_mapseen_feat->lava;                             /* (Bitfield(lava, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "lava",  2);
    bitfield = d_mapseen_feat->ice;                              /* (Bitfield(ice, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ice",  2);
    bitfield = d_mapseen_feat->nshop;                            /* (Bitfield(nshop, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "nshop",  2);
    bitfield = d_mapseen_feat->ntemple;                          /* (Bitfield(ntemple, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ntemple",  2);
    bitfield = d_mapseen_feat->msalign;                          /* (Bitfield(msalign, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "msalign",  2);
    bitfield = d_mapseen_feat->shoptype;                         /* (Bitfield(shoptype, 5)) */
    sfo_bitfield(nhfp, &bitfield, parent, "shoptype",  5);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "mapseen_feat", 1);
}

void
sfo_mapseen_flags(nhfp, d_mapseen_flags, myparent, myname, cnt)
NHFILE *nhfp;
struct mapseen_flags *d_mapseen_flags;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mapseen_flags";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "mapseen_flags", 1);

    bitfield = d_mapseen_flags->unreachable;                     /* (Bitfield(unreachable, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "unreachable",  1);
    bitfield = d_mapseen_flags->forgot;                          /* (Bitfield(forgot, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "forgot",  1);
    bitfield = d_mapseen_flags->knownbones;                      /* (Bitfield(knownbones, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "knownbones",  1);
    bitfield = d_mapseen_flags->oracle;                          /* (Bitfield(oracle, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oracle",  1);
    bitfield = d_mapseen_flags->sokosolved;                      /* (Bitfield(sokosolved, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "sokosolved",  1);
    bitfield = d_mapseen_flags->bigroom;                         /* (Bitfield(bigroom, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "bigroom",  1);
    bitfield = d_mapseen_flags->castle;                          /* (Bitfield(castle, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "castle",  1);
    bitfield = d_mapseen_flags->castletune;                      /* (Bitfield(castletune, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "castletune",  1);
    bitfield = d_mapseen_flags->valley;                          /* (Bitfield(valley, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "valley",  1);
    bitfield = d_mapseen_flags->msanctum;                        /* (Bitfield(msanctum, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "msanctum",  1);
    bitfield = d_mapseen_flags->ludios;                          /* (Bitfield(ludios, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ludios",  1);
    bitfield = d_mapseen_flags->roguelevel;                      /* (Bitfield(roguelevel, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "roguelevel",  1);
    bitfield = d_mapseen_flags->quest_summons;                   /* (Bitfield(quest_summons, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "quest_summons",  1);
    bitfield = d_mapseen_flags->questing;                        /* (Bitfield(questing, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "questing",  1);
    bitfield = d_mapseen_flags->vibrating_square;                /* (Bitfield(vibrating_square, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "vibrating_square",  1);
    bitfield = d_mapseen_flags->spare1;                          /* (Bitfield(spare1, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "spare1",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "mapseen_flags", 1);
}

void
sfo_mapseen_rooms(nhfp, d_mapseen_rooms, myparent, myname, cnt)
NHFILE *nhfp;
struct mapseen_rooms *d_mapseen_rooms;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mapseen_rooms";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "mapseen_rooms", 1);

    bitfield = d_mapseen_rooms->seen;                            /* (Bitfield(seen, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "seen",  1);
    bitfield = d_mapseen_rooms->untended;                        /* (Bitfield(untended, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "untended",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "mapseen_rooms", 1);
}

void
sfo_mapseen(nhfp, d_mapseen, myparent, myname, cnt)
NHFILE *nhfp;
struct mapseen *d_mapseen;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mapseen";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "mapseen", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_mapseen->next, parent, "next", 1);/* (struct mapseen *) */
    sfo_branch(nhfp, d_mapseen->br, parent, "br", 1);            /* (branch *) */
    sfo_d_level(nhfp, &d_mapseen->lev, parent, "lev", 1);        /* (d_level) */
    sfo_mapseen_feat(nhfp, &d_mapseen->feat, parent, "feat", 1); /* (}) */
    sfo_mapseen_flags(nhfp, &d_mapseen->flags, parent, "flags", 1);/* (}) */
    sfo_char(nhfp, d_mapseen->custom, parent, "custom", 1);      /* (char *) */
    sfo_unsigned(nhfp, &d_mapseen->custom_lth, parent, "custom_lth", 1);/* (unsigned) */
    for (i = 0; i < (MAXNROFROOMS + 1) * 2; ++i)
        sfo_mapseen_rooms(nhfp, &d_mapseen->msrooms[i], parent, "msrooms", 1);/* (}) */
    sfo_genericptr(nhfp, (genericptr_t) &d_mapseen->final_resting_place, parent, "final_resting_place", 1);/* (struct cemetery *) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "mapseen", 1);
}

void
sfo_mextra(nhfp, d_mextra, myparent, myname, cnt)
NHFILE *nhfp;
struct mextra *d_mextra;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mextra";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "mextra", 1);

    sfo_char(nhfp, d_mextra->mname, parent, "mname", 1);         /* (char *) */
    sfo_egd(nhfp, d_mextra->egd, parent, "egd", 1);              /* (struct egd *) */
    sfo_epri(nhfp, d_mextra->epri, parent, "epri", 1);           /* (struct epri *) */
    sfo_eshk(nhfp, d_mextra->eshk, parent, "eshk", 1);           /* (struct eshk *) */
    sfo_emin(nhfp, d_mextra->emin, parent, "emin", 1);           /* (struct emin *) */
    sfo_edog(nhfp, d_mextra->edog, parent, "edog", 1);           /* (struct edog *) */
    sfo_int(nhfp, &d_mextra->mcorpsenm, parent, "mcorpsenm", 1); /* (int) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "mextra", 1);
}

void
sfo_mkroom(nhfp, d_mkroom, myparent, myname, cnt)
NHFILE *nhfp;
struct mkroom *d_mkroom;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mkroom";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "mkroom", 1);

    sfo_schar(nhfp, &d_mkroom->lx, parent, "lx", 1);             /* (schar) */
    sfo_schar(nhfp, &d_mkroom->hx, parent, "hx", 1);             /* (schar) */
    sfo_schar(nhfp, &d_mkroom->ly, parent, "ly", 1);             /* (schar) */
    sfo_schar(nhfp, &d_mkroom->hy, parent, "hy", 1);             /* (schar) */
    sfo_schar(nhfp, &d_mkroom->rtype, parent, "rtype", 1);       /* (schar) */
    sfo_schar(nhfp, &d_mkroom->orig_rtype, parent, "orig_rtype", 1);/* (schar) */
    sfo_schar(nhfp, &d_mkroom->rlit, parent, "rlit", 1);         /* (schar) */
    sfo_schar(nhfp, &d_mkroom->needfill, parent, "needfill", 1); /* (schar) */
    sfo_schar(nhfp, &d_mkroom->needjoining, parent, "needjoining", 1);/* (schar) */
    sfo_schar(nhfp, &d_mkroom->doorct, parent, "doorct", 1);     /* (schar) */
    sfo_schar(nhfp, &d_mkroom->fdoor, parent, "fdoor", 1);       /* (schar) */
    sfo_schar(nhfp, &d_mkroom->nsubrooms, parent, "nsubrooms", 1);/* (schar) */
    sfo_boolean(nhfp, &d_mkroom->irregular, parent, "irregular", 1);/* (boolean) */
    sfo_genericptr(nhfp, (genericptr_t) &d_mkroom->sbrooms[0], parent, "sbrooms", MAX_SUBROOMS);/* (struct mkroom *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_mkroom->resident, parent, "resident", 1);/* (struct monst *) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "mkroom", 1);
}

void
sfo_monst(nhfp, d_monst, myparent, myname, cnt)
NHFILE *nhfp;
struct monst *d_monst;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "monst";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "monst", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_monst->nmon, parent, "nmon", 1);/* (struct monst *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_monst->data, parent, "data", 1);/* (struct permonst *) */
    sfo_unsigned(nhfp, &d_monst->m_id, parent, "m_id", 1);       /* (unsigned) */
    sfo_short(nhfp, &d_monst->mnum, parent, "mnum", 1);          /* (short) */
    sfo_short(nhfp, &d_monst->cham, parent, "cham", 1);          /* (short) */
    sfo_short(nhfp, &d_monst->movement, parent, "movement", 1);  /* (short) */
    sfo_uchar(nhfp, &d_monst->m_lev, parent, "m_lev", 1);        /* (uchar) */
    sfo_aligntyp(nhfp, &d_monst->malign, parent, "malign", 1);   /* (aligntyp) */
    sfo_xchar(nhfp, &d_monst->mx, parent, "mx", 1);              /* (xchar) */
    sfo_xchar(nhfp, &d_monst->my, parent, "my", 1);              /* (xchar) */
    sfo_xchar(nhfp, &d_monst->mux, parent, "mux", 1);            /* (xchar) */
    sfo_xchar(nhfp, &d_monst->muy, parent, "muy", 1);            /* (xchar) */
    for (i = 0; i < MTSZ; ++i)
        sfo_nhcoord(nhfp, &d_monst->mtrack[i], parent, "mtrack", 1);/* (nhcoord) */
    sfo_int(nhfp, &d_monst->mhp, parent, "mhp", 1);              /* (int) */
    sfo_int(nhfp, &d_monst->mhpmax, parent, "mhpmax", 1);        /* (int) */
    sfo_unsigned(nhfp, &d_monst->mappearance, parent, "mappearance", 1);/* (unsigned) */
    sfo_uchar(nhfp, &d_monst->m_ap_type, parent, "m_ap_type", 1);/* (uchar) */
    sfo_schar(nhfp, &d_monst->mtame, parent, "mtame", 1);        /* (schar) */
    sfo_ushort(nhfp, &d_monst->mextrinsics, parent, "mextrinsics", 1);/* (unsigned short) */
    sfo_int(nhfp, &d_monst->mspec_used, parent, "mspec_used", 1);/* (int) */
    bitfield = d_monst->female;                                  /* (Bitfield(female, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "female",  1);
    bitfield = d_monst->minvis;                                  /* (Bitfield(minvis, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "minvis",  1);
    bitfield = d_monst->invis_blkd;                              /* (Bitfield(invis_blkd, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "invis_blkd",  1);
    bitfield = d_monst->perminvis;                               /* (Bitfield(perminvis, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "perminvis",  1);
    bitfield = d_monst->mcan;                                    /* (Bitfield(mcan, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mcan",  1);
    bitfield = d_monst->mburied;                                 /* (Bitfield(mburied, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mburied",  1);
    bitfield = d_monst->mundetected;                             /* (Bitfield(mundetected, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mundetected",  1);
    bitfield = d_monst->mcansee;                                 /* (Bitfield(mcansee, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mcansee",  1);
    bitfield = d_monst->mspeed;                                  /* (Bitfield(mspeed, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mspeed",  2);
    bitfield = d_monst->permspeed;                               /* (Bitfield(permspeed, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "permspeed",  2);
    bitfield = d_monst->mrevived;                                /* (Bitfield(mrevived, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mrevived",  1);
    bitfield = d_monst->mcloned;                                 /* (Bitfield(mcloned, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mcloned",  1);
    bitfield = d_monst->mavenge;                                 /* (Bitfield(mavenge, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mavenge",  1);
    bitfield = d_monst->mflee;                                   /* (Bitfield(mflee, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mflee",  1);
    bitfield = d_monst->mfleetim;                                /* (Bitfield(mfleetim, 7)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mfleetim",  7);
    bitfield = d_monst->msleeping;                               /* (Bitfield(msleeping, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "msleeping",  1);
    bitfield = d_monst->mblinded;                                /* (Bitfield(mblinded, 7)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mblinded",  7);
    bitfield = d_monst->mstun;                                   /* (Bitfield(mstun, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mstun",  1);
    bitfield = d_monst->mfrozen;                                 /* (Bitfield(mfrozen, 7)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mfrozen",  7);
    bitfield = d_monst->mcanmove;                                /* (Bitfield(mcanmove, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mcanmove",  1);
    bitfield = d_monst->mconf;                                   /* (Bitfield(mconf, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mconf",  1);
    bitfield = d_monst->mpeaceful;                               /* (Bitfield(mpeaceful, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mpeaceful",  1);
    bitfield = d_monst->mtrapped;                                /* (Bitfield(mtrapped, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mtrapped",  1);
    bitfield = d_monst->mleashed;                                /* (Bitfield(mleashed, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mleashed",  1);
    bitfield = d_monst->isshk;                                   /* (Bitfield(isshk, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "isshk",  1);
    bitfield = d_monst->isminion;                                /* (Bitfield(isminion, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "isminion",  1);
    bitfield = d_monst->isgd;                                    /* (Bitfield(isgd, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "isgd",  1);
    bitfield = d_monst->ispriest;                                /* (Bitfield(ispriest, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ispriest",  1);
    bitfield = d_monst->iswiz;                                   /* (Bitfield(iswiz, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "iswiz",  1);
    bitfield = d_monst->wormno;                                  /* (Bitfield(wormno, 5)) */
    sfo_bitfield(nhfp, &bitfield, parent, "wormno",  5);
    bitfield = d_monst->mtemplit;                                /* (Bitfield(mtemplit, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mtemplit",  1);
    sfo_ulong(nhfp, &d_monst->mstrategy, parent, "mstrategy", 1);/* (unsigned long) */
    sfo_long(nhfp, &d_monst->mtrapseen, parent, "mtrapseen", 1); /* (long) */
    sfo_long(nhfp, &d_monst->mlstmv, parent, "mlstmv", 1);       /* (long) */
    sfo_long(nhfp, &d_monst->mstate, parent, "mstate", 1);       /* (long) */
    sfo_long(nhfp, &d_monst->migflags, parent, "migflags", 1);   /* (long) */
    sfo_long(nhfp, &d_monst->mspare1, parent, "mspare1", 1);     /* (long) */
    sfo_genericptr(nhfp, (genericptr_t) &d_monst->minvent, parent, "minvent", 1);/* (struct obj *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_monst->mw, parent, "mw", 1);/* (struct obj *) */
    sfo_long(nhfp, &d_monst->misc_worn_check, parent, "misc_worn_check", 1);/* (long) */
    sfo_xchar(nhfp, &d_monst->weapon_check, parent, "weapon_check", 1);/* (xchar) */
    sfo_int(nhfp, &d_monst->meating, parent, "meating", 1);      /* (int) */
    sfo_genericptr(nhfp, (genericptr_t) &d_monst->mextra, parent, "mextra", 1);/* (struct mextra *) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "monst", 1);
}

void
sfo_mvitals(nhfp, d_mvitals, myparent, myname, cnt)
NHFILE *nhfp;
struct mvitals *d_mvitals;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mvitals";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "mvitals", 1);

    sfo_uchar(nhfp, &d_mvitals->born, parent, "born", 1);        /* (uchar) */
    sfo_uchar(nhfp, &d_mvitals->died, parent, "died", 1);        /* (uchar) */
    sfo_uchar(nhfp, &d_mvitals->mvflags, parent, "mvflags", 1);  /* (uchar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "mvitals", 1);
}

void
sfo_nhcoord(nhfp, d_nhcoord, myparent, myname, cnt)
NHFILE *nhfp;
struct nhcoord *d_nhcoord;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "nhcoord";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "nhcoord", 1);

    sfo_xchar(nhfp, &d_nhcoord->x, parent, "x", 1);              /* (xchar) */
    sfo_xchar(nhfp, &d_nhcoord->y, parent, "y", 1);              /* (xchar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "nhcoord", 1);
}

void
sfo_nhrect(nhfp, d_nhrect, myparent, myname, cnt)
NHFILE *nhfp;
struct nhrect *d_nhrect;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "nhrect";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "nhrect", 1);

    sfo_xchar(nhfp, &d_nhrect->lx, parent, "lx", 1);             /* (xchar) */
    sfo_xchar(nhfp, &d_nhrect->ly, parent, "ly", 1);             /* (xchar) */
    sfo_xchar(nhfp, &d_nhrect->hx, parent, "hx", 1);             /* (xchar) */
    sfo_xchar(nhfp, &d_nhrect->hy, parent, "hy", 1);             /* (xchar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "nhrect", 1);
}

void
sfo_novel_tracking(nhfp, d_novel_tracking, myparent, myname, cnt)
NHFILE *nhfp;
struct novel_tracking *d_novel_tracking;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "novel_tracking";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "novel_tracking", 1);

    sfo_unsigned(nhfp, &d_novel_tracking->id, parent, "id", 1);  /* (unsigned) */
    sfo_int(nhfp, &d_novel_tracking->count, parent, "count", 1); /* (int) */
    sfo_xchar(nhfp, d_novel_tracking->pasg, parent, "pasg", 30); /* (xchar) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "novel_tracking", 1);
}

void
sfo_obj(nhfp, d_obj, myparent, myname, cnt)
NHFILE *nhfp;
struct obj *d_obj;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "obj";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "obj", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_obj->nobj, parent, "nobj", 1);/* (struct obj *) */
    sfo_vptrs(nhfp, &d_obj->v, parent, "v", 1);                  /* (vptrs) */
    sfo_genericptr(nhfp, (genericptr_t) &d_obj->cobj, parent, "cobj", 1);/* (struct obj *) */
    sfo_unsigned(nhfp, &d_obj->o_id, parent, "o_id", 1);         /* (unsigned) */
    sfo_xchar(nhfp, &d_obj->ox, parent, "ox", 1);                /* (xchar) */
    sfo_xchar(nhfp, &d_obj->oy, parent, "oy", 1);                /* (xchar) */
    sfo_short(nhfp, &d_obj->otyp, parent, "otyp", 1);            /* (short) */
    sfo_unsigned(nhfp, &d_obj->owt, parent, "owt", 1);           /* (unsigned) */
    sfo_long(nhfp, &d_obj->quan, parent, "quan", 1);             /* (long) */
    sfo_schar(nhfp, &d_obj->spe, parent, "spe", 1);              /* (schar) */
    sfo_char(nhfp, &d_obj->oclass, parent, "oclass", 1);         /* (char) */
    sfo_char(nhfp, &d_obj->invlet, parent, "invlet", 1);         /* (char) */
    sfo_char(nhfp, &d_obj->oartifact, parent, "oartifact", 1);   /* (char) */
    sfo_xchar(nhfp, &d_obj->where, parent, "where", 1);          /* (xchar) */
    sfo_xchar(nhfp, &d_obj->timed, parent, "timed", 1);          /* (xchar) */
    bitfield = d_obj->cursed;                                    /* (Bitfield(cursed, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "cursed",  1);
    bitfield = d_obj->blessed;                                   /* (Bitfield(blessed, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "blessed",  1);
    bitfield = d_obj->unpaid;                                    /* (Bitfield(unpaid, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "unpaid",  1);
    bitfield = d_obj->no_charge;                                 /* (Bitfield(no_charge, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "no_charge",  1);
    bitfield = d_obj->known;                                     /* (Bitfield(known, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "known",  1);
    bitfield = d_obj->dknown;                                    /* (Bitfield(dknown, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "dknown",  1);
    bitfield = d_obj->bknown;                                    /* (Bitfield(bknown, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "bknown",  1);
    bitfield = d_obj->rknown;                                    /* (Bitfield(rknown, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "rknown",  1);
    bitfield = d_obj->oeroded;                                   /* (Bitfield(oeroded, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oeroded",  2);
    bitfield = d_obj->oeroded2;                                  /* (Bitfield(oeroded2, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oeroded2",  2);
    bitfield = d_obj->oerodeproof;                               /* (Bitfield(oerodeproof, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oerodeproof",  1);
    bitfield = d_obj->olocked;                                   /* (Bitfield(olocked, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "olocked",  1);
    bitfield = d_obj->obroken;                                   /* (Bitfield(obroken, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "obroken",  1);
    bitfield = d_obj->otrapped;                                  /* (Bitfield(otrapped, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "otrapped",  1);
    bitfield = d_obj->recharged;                                 /* (Bitfield(recharged, 3)) */
    sfo_bitfield(nhfp, &bitfield, parent, "recharged",  3);
    bitfield = d_obj->lamplit;                                   /* (Bitfield(lamplit, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "lamplit",  1);
    bitfield = d_obj->globby;                                    /* (Bitfield(globby, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "globby",  1);
    bitfield = d_obj->greased;                                   /* (Bitfield(greased, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "greased",  1);
    bitfield = d_obj->nomerge;                                   /* (Bitfield(nomerge, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "nomerge",  1);
    bitfield = d_obj->was_thrown;                                /* (Bitfield(was_thrown, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "was_thrown",  1);
    bitfield = d_obj->in_use;                                    /* (Bitfield(in_use, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "in_use",  1);
    bitfield = d_obj->bypass;                                    /* (Bitfield(bypass, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "bypass",  1);
    bitfield = d_obj->cknown;                                    /* (Bitfield(cknown, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "cknown",  1);
    bitfield = d_obj->lknown;                                    /* (Bitfield(lknown, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "lknown",  1);
    sfo_int(nhfp, &d_obj->corpsenm, parent, "corpsenm", 1);      /* (int) */
    sfo_int(nhfp, &d_obj->usecount, parent, "usecount", 1);      /* (int) */
    sfo_unsigned(nhfp, &d_obj->oeaten, parent, "oeaten", 1);     /* (unsigned) */
    sfo_long(nhfp, &d_obj->age, parent, "age", 1);               /* (long) */
    sfo_long(nhfp, &d_obj->owornmask, parent, "owornmask", 1);   /* (long) */
    sfo_genericptr(nhfp, (genericptr_t) &d_obj->oextra, parent, "oextra", 1);/* (struct oextra *) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "obj", 1);
}

void
sfo_objclass(nhfp, d_objclass, myparent, myname, cnt)
NHFILE *nhfp;
struct objclass *d_objclass;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "objclass";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "objclass", 1);

    sfo_short(nhfp, &d_objclass->oc_name_idx, parent, "oc_name_idx", 1);/* (short) */
    sfo_short(nhfp, &d_objclass->oc_descr_idx, parent, "oc_descr_idx", 1);/* (short) */
    sfo_genericptr(nhfp, (genericptr_t) &d_objclass->oc_uname, parent, "oc_uname", 1);/* (char *) */
    bitfield = d_objclass->oc_name_known;                        /* (Bitfield(oc_name_known, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_name_known",  1);
    bitfield = d_objclass->oc_merge;                             /* (Bitfield(oc_merge, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_merge",  1);
    bitfield = d_objclass->oc_uses_known;                        /* (Bitfield(oc_uses_known, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_uses_known",  1);
    bitfield = d_objclass->oc_pre_discovered;                    /* (Bitfield(oc_pre_discovered, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_pre_discovered",  1);
    bitfield = d_objclass->oc_magic;                             /* (Bitfield(oc_magic, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_magic",  1);
    bitfield = d_objclass->oc_charged;                           /* (Bitfield(oc_charged, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_charged",  1);
    bitfield = d_objclass->oc_unique;                            /* (Bitfield(oc_unique, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_unique",  1);
    bitfield = d_objclass->oc_nowish;                            /* (Bitfield(oc_nowish, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_nowish",  1);
    bitfield = d_objclass->oc_big;                               /* (Bitfield(oc_big, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_big",  1);
    bitfield = d_objclass->oc_tough;                             /* (Bitfield(oc_tough, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_tough",  1);
    bitfield = d_objclass->oc_dir;                               /* (Bitfield(oc_dir, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_dir",  2);
    bitfield = d_objclass->oc_material;                          /* (Bitfield(oc_material, 5)) */
    sfo_bitfield(nhfp, &bitfield, parent, "oc_material",  5);
    sfo_schar(nhfp, &d_objclass->oc_subtyp, parent, "oc_subtyp", 1);/* (schar) */
    sfo_uchar(nhfp, &d_objclass->oc_oprop, parent, "oc_oprop", 1);/* (uchar) */
    sfo_char(nhfp, &d_objclass->oc_class, parent, "oc_class", 1);/* (char) */
    sfo_schar(nhfp, &d_objclass->oc_delay, parent, "oc_delay", 1);/* (schar) */
    sfo_uchar(nhfp, &d_objclass->oc_color, parent, "oc_color", 1);/* (uchar) */
    sfo_short(nhfp, &d_objclass->oc_prob, parent, "oc_prob", 1); /* (short) */
    sfo_ushort(nhfp, &d_objclass->oc_weight, parent, "oc_weight", 1);/* (unsigned short) */
    sfo_short(nhfp, &d_objclass->oc_cost, parent, "oc_cost", 1); /* (short) */
    sfo_schar(nhfp, &d_objclass->oc_wsdam, parent, "oc_wsdam", 1);/* (schar) */
    sfo_schar(nhfp, &d_objclass->oc_wldam, parent, "oc_wldam", 1);/* (schar) */
    sfo_schar(nhfp, &d_objclass->oc_oc1, parent, "oc_oc1", 1);   /* (schar) */
    sfo_schar(nhfp, &d_objclass->oc_oc2, parent, "oc_oc2", 1);   /* (schar) */
    sfo_ushort(nhfp, &d_objclass->oc_nutrition, parent, "oc_nutrition", 1);/* (unsigned short) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "objclass", 1);
}

void
sfo_obj_split(nhfp, d_obj_split, myparent, myname, cnt)
NHFILE *nhfp;
struct obj_split *d_obj_split;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "obj_split";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "obj_split", 1);

    sfo_unsigned(nhfp, &d_obj_split->parent_oid, parent, "parent_oid", 1);/* (unsigned) */
    sfo_unsigned(nhfp, &d_obj_split->child_oid, parent, "child_oid", 1);/* (unsigned) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "obj_split", 1);
}

void
sfo_oextra(nhfp, d_oextra, myparent, myname, cnt)
NHFILE *nhfp;
struct oextra *d_oextra;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "oextra";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "oextra", 1);

    sfo_char(nhfp, d_oextra->oname, parent, "oname", 1);         /* (char *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_oextra->omonst, parent, "omonst", 1);/* (struct monst *) */
    sfo_unsigned(nhfp, d_oextra->omid, parent, "omid", 1);       /* (unsigned *) */
    sfo_long(nhfp, d_oextra->olong, parent, "olong", 1);         /* (long *) */
    sfo_char(nhfp, d_oextra->omailcmd, parent, "omailcmd", 1);   /* (char *) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "oextra", 1);
}

void
sfo_polearm_info(nhfp, d_polearm_info, myparent, myname, cnt)
NHFILE *nhfp;
struct polearm_info *d_polearm_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "polearm_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "polearm_info", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_polearm_info->hitmon, parent, "hitmon", 1);/* (struct monst *) */
    sfo_unsigned(nhfp, &d_polearm_info->m_id, parent, "m_id", 1);/* (unsigned) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "polearm_info", 1);
}

void
sfo_prop(nhfp, d_prop, myparent, myname, cnt)
NHFILE *nhfp;
struct prop *d_prop;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "prop";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "prop", 1);

    sfo_long(nhfp, &d_prop->extrinsic, parent, "extrinsic", 1);  /* (long) */
    sfo_long(nhfp, &d_prop->blocked, parent, "blocked", 1);      /* (long) */
    sfo_long(nhfp, &d_prop->intrinsic, parent, "intrinsic", 1);  /* (long) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "prop", 1);
}

void
sfo_q_score(nhfp, d_q_score, myparent, myname, cnt)
NHFILE *nhfp;
struct q_score *d_q_score;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "q_score";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "q_score", 1);

    bitfield = d_q_score->first_start;                           /* (Bitfield(first_start, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "first_start",  1);
    bitfield = d_q_score->met_leader;                            /* (Bitfield(met_leader, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "met_leader",  1);
    bitfield = d_q_score->not_ready;                             /* (Bitfield(not_ready, 3)) */
    sfo_bitfield(nhfp, &bitfield, parent, "not_ready",  3);
    bitfield = d_q_score->pissed_off;                            /* (Bitfield(pissed_off, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "pissed_off",  1);
    bitfield = d_q_score->got_quest;                             /* (Bitfield(got_quest, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "got_quest",  1);
    bitfield = d_q_score->first_locate;                          /* (Bitfield(first_locate, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "first_locate",  1);
    bitfield = d_q_score->met_intermed;                          /* (Bitfield(met_intermed, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "met_intermed",  1);
    bitfield = d_q_score->got_final;                             /* (Bitfield(got_final, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "got_final",  1);
    bitfield = d_q_score->made_goal;                             /* (Bitfield(made_goal, 3)) */
    sfo_bitfield(nhfp, &bitfield, parent, "made_goal",  3);
    bitfield = d_q_score->met_nemesis;                           /* (Bitfield(met_nemesis, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "met_nemesis",  1);
    bitfield = d_q_score->killed_nemesis;                        /* (Bitfield(killed_nemesis, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "killed_nemesis",  1);
    bitfield = d_q_score->in_battle;                             /* (Bitfield(in_battle, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "in_battle",  1);
    bitfield = d_q_score->cheater;                               /* (Bitfield(cheater, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "cheater",  1);
    bitfield = d_q_score->touched_artifact;                      /* (Bitfield(touched_artifact, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "touched_artifact",  1);
    bitfield = d_q_score->offered_artifact;                      /* (Bitfield(offered_artifact, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "offered_artifact",  1);
    bitfield = d_q_score->got_thanks;                            /* (Bitfield(got_thanks, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "got_thanks",  1);
    bitfield = d_q_score->ldrgend;                               /* (Bitfield(ldrgend, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ldrgend",  2);
    bitfield = d_q_score->nemgend;                               /* (Bitfield(nemgend, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "nemgend",  2);
    bitfield = d_q_score->godgend;                               /* (Bitfield(godgend, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "godgend",  2);
    bitfield = d_q_score->leader_is_dead;                        /* (Bitfield(leader_is_dead, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "leader_is_dead",  1);
    sfo_unsigned(nhfp, &d_q_score->leader_m_id, parent, "leader_m_id", 1);/* (unsigned) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "q_score", 1);
}

void
sfo_rm(nhfp, d_rm, myparent, myname, cnt)
NHFILE *nhfp;
struct rm *d_rm;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "rm";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "rm", 1);

    sfo_int(nhfp, &d_rm->glyph, parent, "glyph", 1);             /* (int) */
    sfo_schar(nhfp, &d_rm->typ, parent, "typ", 1);               /* (schar) */
    sfo_uchar(nhfp, &d_rm->seenv, parent, "seenv", 1);           /* (uchar) */
    bitfield = d_rm->flags;                                      /* (Bitfield(flags, 5)) */
    sfo_bitfield(nhfp, &bitfield, parent, "flags",  5);
    bitfield = d_rm->horizontal;                                 /* (Bitfield(horizontal, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "horizontal",  1);
    bitfield = d_rm->lit;                                        /* (Bitfield(lit, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "lit",  1);
    bitfield = d_rm->waslit;                                     /* (Bitfield(waslit, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "waslit",  1);
    bitfield = d_rm->roomno;                                     /* (Bitfield(roomno, 6)) */
    sfo_bitfield(nhfp, &bitfield, parent, "roomno",  6);
    bitfield = d_rm->edge;                                       /* (Bitfield(edge, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "edge",  1);
    bitfield = d_rm->candig;                                     /* (Bitfield(candig, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "candig",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "rm", 1);
}

void
sfo_s_level(nhfp, d_s_level, myparent, myname, cnt)
NHFILE *nhfp;
struct s_level *d_s_level;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "s_level";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "s_level", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_s_level->next, parent, "next", 1);/* (struct s_level *) */
    sfo_d_level(nhfp, &d_s_level->dlevel, parent, "dlevel", 1);  /* (d_level) */
    sfo_char(nhfp, d_s_level->proto, parent, "proto", 15);       /* (char) */
    sfo_char(nhfp, &d_s_level->boneid, parent, "boneid", 1);     /* (char) */
    sfo_uchar(nhfp, &d_s_level->rndlevs, parent, "rndlevs", 1);  /* (uchar) */
    sfo_d_flags(nhfp, &d_s_level->flags, parent, "flags", 1);    /* (d_flags) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "s_level", 1);
}

void
sfo_savefile_info(nhfp, d_savefile_info, myparent, myname, cnt)
NHFILE *nhfp;
struct savefile_info *d_savefile_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "savefile_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "savefile_info", 1);

    sfo_ulong(nhfp, &d_savefile_info->sfi1, parent, "sfi1", 1);  /* (unsigned long) */
    sfo_ulong(nhfp, &d_savefile_info->sfi2, parent, "sfi2", 1);  /* (unsigned long) */
    sfo_ulong(nhfp, &d_savefile_info->sfi3, parent, "sfi3", 1);  /* (unsigned long) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "savefile_info", 1);
}

void
sfo_skills(nhfp, d_skills, myparent, myname, cnt)
NHFILE *nhfp;
struct skills *d_skills;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "skills";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "skills", 1);

    sfo_xchar(nhfp, &d_skills->skill, parent, "skill", 1);       /* (xchar) */
    sfo_xchar(nhfp, &d_skills->max_skill, parent, "max_skill", 1);/* (xchar) */
    sfo_ushort(nhfp, &d_skills->advance, parent, "advance", 1);  /* (unsigned short) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "skills", 1);
}

void
sfo_spell(nhfp, d_spell, myparent, myname, cnt)
NHFILE *nhfp;
struct spell *d_spell;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "spell";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "spell", 1);

    sfo_short(nhfp, &d_spell->sp_id, parent, "sp_id", 1);        /* (short) */
    sfo_xchar(nhfp, &d_spell->sp_lev, parent, "sp_lev", 1);      /* (xchar) */
    sfo_int(nhfp, &d_spell->sp_know, parent, "sp_know", 1);      /* (int) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "spell", 1);
}

void
sfo_stairway(nhfp, d_stairway, myparent, myname, cnt)
NHFILE *nhfp;
struct stairway *d_stairway;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "stairway";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "stairway", 1);

    sfo_xchar(nhfp, &d_stairway->sx, parent, "sx", 1);           /* (xchar) */
    sfo_xchar(nhfp, &d_stairway->sy, parent, "sy", 1);           /* (xchar) */
    sfo_d_level(nhfp, &d_stairway->tolev, parent, "tolev", 1);   /* (d_level) */
    sfo_char(nhfp, &d_stairway->up, parent, "up", 1);            /* (char) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "stairway", 1);
}

void
sfo_takeoff_info(nhfp, d_takeoff_info, myparent, myname, cnt)
NHFILE *nhfp;
struct takeoff_info *d_takeoff_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "takeoff_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "takeoff_info", 1);

    sfo_long(nhfp, &d_takeoff_info->mask, parent, "mask", 1);    /* (long) */
    sfo_long(nhfp, &d_takeoff_info->what, parent, "what", 1);    /* (long) */
    sfo_int(nhfp, &d_takeoff_info->delay, parent, "delay", 1);   /* (int) */
    sfo_boolean(nhfp, &d_takeoff_info->cancelled_don, parent, "cancelled_don", 1);/* (boolean) */
    sfo_char(nhfp, d_takeoff_info->disrobing, parent, "disrobing", CONTEXTVERBSZ + 1);/* (char) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "takeoff_info", 1);
}

void
sfo_tin_info(nhfp, d_tin_info, myparent, myname, cnt)
NHFILE *nhfp;
struct tin_info *d_tin_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "tin_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "tin_info", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_tin_info->tin, parent, "tin", 1);/* (struct obj *) */
    sfo_unsigned(nhfp, &d_tin_info->o_id, parent, "o_id", 1);    /* (unsigned) */
    sfo_int(nhfp, &d_tin_info->usedtime, parent, "usedtime", 1); /* (int) */
    sfo_int(nhfp, &d_tin_info->reqtime, parent, "reqtime", 1);   /* (int) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "tin_info", 1);
}

void
sfo_trap(nhfp, d_trap, myparent, myname, cnt)
NHFILE *nhfp;
struct trap *d_trap;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "trap";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "trap", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_trap->ntrap, parent, "ntrap", 1);/* (struct trap *) */
    sfo_xchar(nhfp, &d_trap->tx, parent, "tx", 1);               /* (xchar) */
    sfo_xchar(nhfp, &d_trap->ty, parent, "ty", 1);               /* (xchar) */
    sfo_d_level(nhfp, &d_trap->dst, parent, "dst", 1);           /* (d_level) */
    sfo_nhcoord(nhfp, &d_trap->launch, parent, "launch", 1);     /* (nhcoord) */
    bitfield = d_trap->ttyp;                                     /* (Bitfield(ttyp, 5)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ttyp",  5);
    bitfield = d_trap->tseen;                                    /* (Bitfield(tseen, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "tseen",  1);
    bitfield = d_trap->once;                                     /* (Bitfield(once, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "once",  1);
    bitfield = d_trap->madeby_u;                                 /* (Bitfield(madeby_u, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "madeby_u",  1);
    sfo_vlaunchinfo(nhfp, &d_trap->vl, parent, "vl", 1);         /* (vlaunchinfo) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "trap", 1);
}

void
sfo_tribute_info(nhfp, d_tribute_info, myparent, myname, cnt)
NHFILE *nhfp;
struct tribute_info *d_tribute_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "tribute_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "tribute_info", 1);

    sfo_size_t(nhfp, &d_tribute_info->tributesz, parent, "tributesz", 1);/* (size_t) */
    sfo_boolean(nhfp, &d_tribute_info->enabled, parent, "enabled", 1);/* (boolean) */
    bitfield = d_tribute_info->bookstock;                        /* (Bitfield(bookstock, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "bookstock",  1);
    bitfield = d_tribute_info->Deathnotice;                      /* (Bitfield(Deathnotice,1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "Deathnotice", 1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "tribute_info", 1);
}

void
sfo_u_achieve(nhfp, d_u_achieve, myparent, myname, cnt)
NHFILE *nhfp;
struct u_achieve *d_u_achieve;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_achieve";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "u_achieve", 1);

    bitfield = d_u_achieve->amulet;                              /* (Bitfield(amulet, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "amulet",  1);
    bitfield = d_u_achieve->bell;                                /* (Bitfield(bell, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "bell",  1);
    bitfield = d_u_achieve->book;                                /* (Bitfield(book, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "book",  1);
    bitfield = d_u_achieve->menorah;                             /* (Bitfield(menorah, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "menorah",  1);
    bitfield = d_u_achieve->enter_gehennom;                      /* (Bitfield(enter_gehennom,1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "enter_gehennom", 1);
    bitfield = d_u_achieve->ascended;                            /* (Bitfield(ascended, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ascended",  1);
    bitfield = d_u_achieve->mines_luckstone;                     /* (Bitfield(mines_luckstone, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mines_luckstone",  1);
    bitfield = d_u_achieve->finish_sokoban;                      /* (Bitfield(finish_sokoban, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "finish_sokoban",  1);
    bitfield = d_u_achieve->killed_medusa;                       /* (Bitfield(killed_medusa, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "killed_medusa",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "u_achieve", 1);
}

void
sfo_u_conduct(nhfp, d_u_conduct, myparent, myname, cnt)
NHFILE *nhfp;
struct u_conduct *d_u_conduct;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_conduct";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "u_conduct", 1);

    sfo_long(nhfp, &d_u_conduct->unvegetarian, parent, "unvegetarian", 1);/* (long) */
    sfo_long(nhfp, &d_u_conduct->unvegan, parent, "unvegan", 1); /* (long) */
    sfo_long(nhfp, &d_u_conduct->food, parent, "food", 1);       /* (long) */
    sfo_long(nhfp, &d_u_conduct->gnostic, parent, "gnostic", 1); /* (long) */
    sfo_long(nhfp, &d_u_conduct->weaphit, parent, "weaphit", 1); /* (long) */
    sfo_long(nhfp, &d_u_conduct->killer, parent, "killer", 1);   /* (long) */
    sfo_long(nhfp, &d_u_conduct->literate, parent, "literate", 1);/* (long) */
    sfo_long(nhfp, &d_u_conduct->polypiles, parent, "polypiles", 1);/* (long) */
    sfo_long(nhfp, &d_u_conduct->polyselfs, parent, "polyselfs", 1);/* (long) */
    sfo_long(nhfp, &d_u_conduct->wishes, parent, "wishes", 1);   /* (long) */
    sfo_long(nhfp, &d_u_conduct->wisharti, parent, "wisharti", 1);/* (long) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "u_conduct", 1);
}

void
sfo_u_event(nhfp, d_u_event, myparent, myname, cnt)
NHFILE *nhfp;
struct u_event *d_u_event;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_event";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "u_event", 1);

    bitfield = d_u_event->minor_oracle;                          /* (Bitfield(minor_oracle, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "minor_oracle",  1);
    bitfield = d_u_event->major_oracle;                          /* (Bitfield(major_oracle, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "major_oracle",  1);
    bitfield = d_u_event->read_tribute;                          /* (Bitfield(read_tribute, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "read_tribute",  1);
    bitfield = d_u_event->qcalled;                               /* (Bitfield(qcalled, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "qcalled",  1);
    bitfield = d_u_event->qexpelled;                             /* (Bitfield(qexpelled, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "qexpelled",  1);
    bitfield = d_u_event->qcompleted;                            /* (Bitfield(qcompleted, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "qcompleted",  1);
    bitfield = d_u_event->uheard_tune;                           /* (Bitfield(uheard_tune, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uheard_tune",  2);
    bitfield = d_u_event->uopened_dbridge;                       /* (Bitfield(uopened_dbridge, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uopened_dbridge",  1);
    bitfield = d_u_event->invoked;                               /* (Bitfield(invoked, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "invoked",  1);
    bitfield = d_u_event->gehennom_entered;                      /* (Bitfield(gehennom_entered, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "gehennom_entered",  1);
    bitfield = d_u_event->uhand_of_elbereth;                     /* (Bitfield(uhand_of_elbereth, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uhand_of_elbereth",  2);
    bitfield = d_u_event->udemigod;                              /* (Bitfield(udemigod, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "udemigod",  1);
    bitfield = d_u_event->uvibrated;                             /* (Bitfield(uvibrated, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uvibrated",  1);
    bitfield = d_u_event->ascended;                              /* (Bitfield(ascended, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "ascended",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "u_event", 1);
}

void
sfo_u_have(nhfp, d_u_have, myparent, myname, cnt)
NHFILE *nhfp;
struct u_have *d_u_have;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_have";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "u_have", 1);

    bitfield = d_u_have->amulet;                                 /* (Bitfield(amulet, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "amulet",  1);
    bitfield = d_u_have->bell;                                   /* (Bitfield(bell, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "bell",  1);
    bitfield = d_u_have->book;                                   /* (Bitfield(book, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "book",  1);
    bitfield = d_u_have->menorah;                                /* (Bitfield(menorah, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "menorah",  1);
    bitfield = d_u_have->questart;                               /* (Bitfield(questart, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "questart",  1);
    bitfield = d_u_have->unused;                                 /* (Bitfield(unused, 3)) */
    sfo_bitfield(nhfp, &bitfield, parent, "unused",  3);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "u_have", 1);
}

void
sfo_u_realtime(nhfp, d_u_realtime, myparent, myname, cnt)
NHFILE *nhfp;
struct u_realtime *d_u_realtime;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_realtime";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "u_realtime", 1);

    sfo_long(nhfp, &d_u_realtime->realtime, parent, "realtime", 1);/* (long) */
    sfo_time_t(nhfp, &d_u_realtime->start_timing, parent, "start_timing", 1);/* (time_t) */
    sfo_time_t(nhfp, &d_u_realtime->finish_time, parent, "finish_time", 1);/* (time_t) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "u_realtime", 1);
}

void
sfo_u_roleplay(nhfp, d_u_roleplay, myparent, myname, cnt)
NHFILE *nhfp;
struct u_roleplay *d_u_roleplay;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_roleplay";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "u_roleplay", 1);

    sfo_boolean(nhfp, &d_u_roleplay->blind, parent, "blind", 1); /* (boolean) */
    sfo_boolean(nhfp, &d_u_roleplay->nudist, parent, "nudist", 1);/* (boolean) */
    sfo_long(nhfp, &d_u_roleplay->numbones, parent, "numbones", 1);/* (long) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "u_roleplay", 1);
}

void
sfo_version_info(nhfp, d_version_info, myparent, myname, cnt)
NHFILE *nhfp;
struct version_info *d_version_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "version_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "version_info", 1);

    sfo_ulong(nhfp, &d_version_info->incarnation, parent, "incarnation", 1);/* (unsigned long) */
    sfo_ulong(nhfp, &d_version_info->feature_set, parent, "feature_set", 1);/* (unsigned long) */
    sfo_ulong(nhfp, &d_version_info->entity_count, parent, "entity_count", 1);/* (unsigned long) */
    sfo_ulong(nhfp, &d_version_info->struct_sizes1, parent, "struct_sizes1", 1);/* (unsigned long) */
    sfo_ulong(nhfp, &d_version_info->struct_sizes2, parent, "struct_sizes2", 1);/* (unsigned long) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "version_info", 1);
}

void
sfo_victual_info(nhfp, d_victual_info, myparent, myname, cnt)
NHFILE *nhfp;
struct victual_info *d_victual_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "victual_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "victual_info", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_victual_info->piece, parent, "piece", 1);/* (struct obj *) */
    sfo_unsigned(nhfp, &d_victual_info->o_id, parent, "o_id", 1);/* (unsigned) */
    sfo_int(nhfp, &d_victual_info->usedtime, parent, "usedtime", 1);/* (int) */
    sfo_int(nhfp, &d_victual_info->reqtime, parent, "reqtime", 1);/* (int) */
    sfo_int(nhfp, &d_victual_info->nmod, parent, "nmod", 1);     /* (int) */
    bitfield = d_victual_info->canchoke;                         /* (Bitfield(canchoke, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "canchoke",  1);
    bitfield = d_victual_info->fullwarn;                         /* (Bitfield(fullwarn, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "fullwarn",  1);
    bitfield = d_victual_info->eating;                           /* (Bitfield(eating, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "eating",  1);
    bitfield = d_victual_info->doreset;                          /* (Bitfield(doreset, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "doreset",  1);

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "victual_info", 1);
}

void
sfo_vlaunchinfo(nhfp, d_vlaunchinfo, myparent, myname, cnt)
NHFILE *nhfp;
union vlaunchinfo *d_vlaunchinfo;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "vlaunchinfo";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "vlaunchinfo", 1);

    sfo_short(nhfp, &d_vlaunchinfo->v_launch_otyp, parent, "v_launch_otyp", 1);/* (short) */
    sfo_nhcoord(nhfp, &d_vlaunchinfo->v_launch2, parent, "v_launch2", 1);/* (nhcoord) */
    sfo_uchar(nhfp, &d_vlaunchinfo->v_conjoined, parent, "v_conjoined", 1);/* (uchar) */
    sfo_short(nhfp, &d_vlaunchinfo->v_tnote, parent, "v_tnote", 1);/* (short) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "vlaunchinfo", 1);
}

void
sfo_vptrs(nhfp, d_vptrs, myparent, myname, cnt)
NHFILE *nhfp;
union vptrs *d_vptrs;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "vptrs";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "vptrs", 1);

    sfo_genericptr(nhfp, (genericptr_t) &d_vptrs->v_nexthere, parent, "v_nexthere", 1);/* (struct obj *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_vptrs->v_ocontainer, parent, "v_ocontainer", 1);/* (struct obj *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_vptrs->v_ocarry, parent, "v_ocarry", 1);/* (struct monst *) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "vptrs", 1);
}

void
sfo_warntype_info(nhfp, d_warntype_info, myparent, myname, cnt)
NHFILE *nhfp;
struct warntype_info *d_warntype_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "warntype_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "warntype_info", 1);

    sfo_ulong(nhfp, &d_warntype_info->obj, parent, "obj", 1);    /* (unsigned long) */
    sfo_ulong(nhfp, &d_warntype_info->polyd, parent, "polyd", 1);/* (unsigned long) */
    sfo_genericptr(nhfp, (genericptr_t) &d_warntype_info->species, parent, "species", 1);/* (struct permonst *) */
    sfo_short(nhfp, &d_warntype_info->speciesidx, parent, "speciesidx", 1);/* (short) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "warntype_info", 1);
}

void
sfo_you(nhfp, d_you, myparent, myname, cnt)
NHFILE *nhfp;
struct you *d_you;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "you";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "start", "you", 1);

    sfo_xchar(nhfp, &d_you->ux, parent, "ux", 1);                /* (xchar) */
    sfo_xchar(nhfp, &d_you->uy, parent, "uy", 1);                /* (xchar) */
    sfo_schar(nhfp, &d_you->dx, parent, "dx", 1);                /* (schar) */
    sfo_schar(nhfp, &d_you->dy, parent, "dy", 1);                /* (schar) */
    sfo_schar(nhfp, &d_you->dz, parent, "dz", 1);                /* (schar) */
    sfo_schar(nhfp, &d_you->di, parent, "di", 1);                /* (schar) */
    sfo_xchar(nhfp, &d_you->tx, parent, "tx", 1);                /* (xchar) */
    sfo_xchar(nhfp, &d_you->ty, parent, "ty", 1);                /* (xchar) */
    sfo_xchar(nhfp, &d_you->ux0, parent, "ux0", 1);              /* (xchar) */
    sfo_xchar(nhfp, &d_you->uy0, parent, "uy0", 1);              /* (xchar) */
    sfo_d_level(nhfp, &d_you->uz, parent, "uz", 1);              /* (d_level) */
    sfo_d_level(nhfp, &d_you->uz0, parent, "uz0", 1);            /* (d_level) */
    sfo_d_level(nhfp, &d_you->utolev, parent, "utolev", 1);      /* (d_level) */
    sfo_uchar(nhfp, &d_you->utotype, parent, "utotype", 1);      /* (uchar) */
    sfo_boolean(nhfp, &d_you->umoved, parent, "umoved", 1);      /* (boolean) */
    sfo_int(nhfp, &d_you->last_str_turn, parent, "last_str_turn", 1);/* (int) */
    sfo_int(nhfp, &d_you->ulevel, parent, "ulevel", 1);          /* (int) */
    sfo_int(nhfp, &d_you->ulevelmax, parent, "ulevelmax", 1);    /* (int) */
    sfo_unsigned(nhfp, &d_you->utrap, parent, "utrap", 1);       /* (unsigned) */
    sfo_unsigned(nhfp, &d_you->utraptype, parent, "utraptype", 1);/* (unsigned) */
    sfo_char(nhfp, d_you->urooms, parent, "urooms", 5);          /* (char) */
    sfo_char(nhfp, d_you->urooms0, parent, "urooms0", 5);        /* (char) */
    sfo_char(nhfp, d_you->uentered, parent, "uentered", 5);      /* (char) */
    sfo_char(nhfp, d_you->ushops, parent, "ushops", 5);          /* (char) */
    sfo_char(nhfp, d_you->ushops0, parent, "ushops0", 5);        /* (char) */
    sfo_char(nhfp, d_you->ushops_entered, parent, "ushops_entered", 5);/* (char) */
    sfo_char(nhfp, d_you->ushops_left, parent, "ushops_left", 5);/* (char) */
    sfo_int(nhfp, &d_you->uhunger, parent, "uhunger", 1);        /* (int) */
    sfo_unsigned(nhfp, &d_you->uhs, parent, "uhs", 1);           /* (unsigned) */
    sfo_prop(nhfp, d_you->uprops, parent, "uprops", LAST_PROP + 1);/* (prop) */
    sfo_unsigned(nhfp, &d_you->umconf, parent, "umconf", 1);     /* (unsigned) */
    bitfield = d_you->usick_type;                                /* (Bitfield(usick_type, 2)) */
    sfo_bitfield(nhfp, &bitfield, parent, "usick_type",  2);
    sfo_int(nhfp, &d_you->nv_range, parent, "nv_range", 1);      /* (int) */
    sfo_int(nhfp, &d_you->xray_range, parent, "xray_range", 1);  /* (int) */
    sfo_int(nhfp, &d_you->bglyph, parent, "bglyph", 1);          /* (int) */
    sfo_int(nhfp, &d_you->cglyph, parent, "cglyph", 1);          /* (int) */
    sfo_int(nhfp, &d_you->bc_order, parent, "bc_order", 1);      /* (int) */
    sfo_int(nhfp, &d_you->bc_felt, parent, "bc_felt", 1);        /* (int) */
    sfo_int(nhfp, &d_you->umonster, parent, "umonster", 1);      /* (int) */
    sfo_int(nhfp, &d_you->umonnum, parent, "umonnum", 1);        /* (int) */
    sfo_int(nhfp, &d_you->mh, parent, "mh", 1);                  /* (int) */
    sfo_int(nhfp, &d_you->mhmax, parent, "mhmax", 1);            /* (int) */
    sfo_int(nhfp, &d_you->mtimedone, parent, "mtimedone", 1);    /* (int) */
    sfo_attribs(nhfp, &d_you->macurr, parent, "macurr", 1);      /* (attribs) */
    sfo_attribs(nhfp, &d_you->mamax, parent, "mamax", 1);        /* (attribs) */
    sfo_int(nhfp, &d_you->ulycn, parent, "ulycn", 1);            /* (int) */
    sfo_unsigned(nhfp, &d_you->ucreamed, parent, "ucreamed", 1); /* (unsigned) */
    sfo_unsigned(nhfp, &d_you->uswldtim, parent, "uswldtim", 1); /* (unsigned) */
    bitfield = d_you->uswallow;                                  /* (Bitfield(uswallow, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uswallow",  1);
    bitfield = d_you->uinwater;                                  /* (Bitfield(uinwater, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uinwater",  1);
    bitfield = d_you->uundetected;                               /* (Bitfield(uundetected, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uundetected",  1);
    bitfield = d_you->mfemale;                                   /* (Bitfield(mfemale, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "mfemale",  1);
    bitfield = d_you->uinvulnerable;                             /* (Bitfield(uinvulnerable, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uinvulnerable",  1);
    bitfield = d_you->uburied;                                   /* (Bitfield(uburied, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uburied",  1);
    bitfield = d_you->uedibility;                                /* (Bitfield(uedibility, 1)) */
    sfo_bitfield(nhfp, &bitfield, parent, "uedibility",  1);
    sfo_unsigned(nhfp, &d_you->udg_cnt, parent, "udg_cnt", 1);   /* (unsigned) */
    sfo_u_achieve(nhfp, &d_you->uachieve, parent, "uachieve", 1);/* (u_achieve) */
    sfo_u_event(nhfp, &d_you->uevent, parent, "uevent", 1);      /* (u_event) */
    sfo_u_have(nhfp, &d_you->uhave, parent, "uhave", 1);         /* (u_have) */
    sfo_u_conduct(nhfp, &d_you->uconduct, parent, "uconduct", 1);/* (u_conduct) */
    sfo_u_roleplay(nhfp, &d_you->uroleplay, parent, "uroleplay", 1);/* (u_roleplay) */
    sfo_attribs(nhfp, &d_you->acurr, parent, "acurr", 1);        /* (attribs) */
    sfo_attribs(nhfp, &d_you->aexe, parent, "aexe", 1);          /* (attribs) */
    sfo_attribs(nhfp, &d_you->abon, parent, "abon", 1);          /* (attribs) */
    sfo_attribs(nhfp, &d_you->amax, parent, "amax", 1);          /* (attribs) */
    sfo_attribs(nhfp, &d_you->atemp, parent, "atemp", 1);        /* (attribs) */
    sfo_attribs(nhfp, &d_you->atime, parent, "atime", 1);        /* (attribs) */
    sfo_align(nhfp, &d_you->ualign, parent, "ualign", 1);        /* (align) */
    for (i = 0; i < CONVERT; ++i)
        sfo_aligntyp(nhfp, &d_you->ualignbase[i], parent, "ualignbase", 1);/* (aligntyp) */
    sfo_schar(nhfp, &d_you->uluck, parent, "uluck", 1);          /* (schar) */
    sfo_schar(nhfp, &d_you->moreluck, parent, "moreluck", 1);    /* (schar) */
    sfo_schar(nhfp, &d_you->uhitinc, parent, "uhitinc", 1);      /* (schar) */
    sfo_schar(nhfp, &d_you->udaminc, parent, "udaminc", 1);      /* (schar) */
    sfo_schar(nhfp, &d_you->uac, parent, "uac", 1);              /* (schar) */
    sfo_uchar(nhfp, &d_you->uspellprot, parent, "uspellprot", 1);/* (uchar) */
    sfo_uchar(nhfp, &d_you->usptime, parent, "usptime", 1);      /* (uchar) */
    sfo_uchar(nhfp, &d_you->uspmtime, parent, "uspmtime", 1);    /* (uchar) */
    sfo_int(nhfp, &d_you->uhp, parent, "uhp", 1);                /* (int) */
    sfo_int(nhfp, &d_you->uhpmax, parent, "uhpmax", 1);          /* (int) */
    sfo_int(nhfp, &d_you->uen, parent, "uen", 1);                /* (int) */
    sfo_int(nhfp, &d_you->uenmax, parent, "uenmax", 1);          /* (int) */
    sfo_xchar(nhfp, d_you->uhpinc, parent, "uhpinc", MAXULEV);   /* (xchar) */
    sfo_xchar(nhfp, d_you->ueninc, parent, "ueninc", MAXULEV);   /* (xchar) */
    sfo_int(nhfp, &d_you->ugangr, parent, "ugangr", 1);          /* (int) */
    sfo_int(nhfp, &d_you->ugifts, parent, "ugifts", 1);          /* (int) */
    sfo_int(nhfp, &d_you->ublessed, parent, "ublessed", 1);      /* (int) */
    sfo_int(nhfp, &d_you->ublesscnt, parent, "ublesscnt", 1);    /* (int) */
    sfo_long(nhfp, &d_you->umoney0, parent, "umoney0", 1);       /* (long) */
    sfo_long(nhfp, &d_you->uspare1, parent, "uspare1", 1);       /* (long) */
    sfo_long(nhfp, &d_you->uexp, parent, "uexp", 1);             /* (long) */
    sfo_long(nhfp, &d_you->urexp, parent, "urexp", 1);           /* (long) */
    sfo_long(nhfp, &d_you->ucleansed, parent, "ucleansed", 1);   /* (long) */
    sfo_long(nhfp, &d_you->usleep, parent, "usleep", 1);         /* (long) */
    sfo_int(nhfp, &d_you->uinvault, parent, "uinvault", 1);      /* (int) */
    sfo_genericptr(nhfp, (genericptr_t) &d_you->ustuck, parent, "ustuck", 1);/* (struct monst *) */
    sfo_genericptr(nhfp, (genericptr_t) &d_you->usteed, parent, "usteed", 1);/* (struct monst *) */
    sfo_long(nhfp, &d_you->ugallop, parent, "ugallop", 1);       /* (long) */
    sfo_int(nhfp, &d_you->urideturns, parent, "urideturns", 1);  /* (int) */
    sfo_int(nhfp, &d_you->umortality, parent, "umortality", 1);  /* (int) */
    sfo_int(nhfp, &d_you->ugrave_arise, parent, "ugrave_arise", 1);/* (int) */
    sfo_int(nhfp, &d_you->weapon_slots, parent, "weapon_slots", 1);/* (int) */
    sfo_int(nhfp, &d_you->skills_advanced, parent, "skills_advanced", 1);/* (int) */
    sfo_xchar(nhfp, d_you->skill_record, parent, "skill_record", P_SKILL_LIMIT);/* (xchar) */
    for (i = 0; i < P_NUM_SKILLS; ++i)
        sfo_skills(nhfp, &d_you->weapon_skills[i], parent, "weapon_skills", 1);/* (skills) */
    sfo_boolean(nhfp, &d_you->twoweap, parent, "twoweap", 1);    /* (boolean) */
    sfo_short(nhfp, &d_you->mcham, parent, "mcham", 1);          /* (short) */

    if (nhfp->addinfo)
        sfo_addinfo(nhfp, myparent, "end", "you", 1);
}

void
sfi_align(nhfp, d_align, myparent, myname, cnt)
NHFILE *nhfp;
struct align *d_align;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "align";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "align", 1);

    sfi_aligntyp(nhfp, &d_align->type, parent, "type", 1);
    sfi_int(nhfp, &d_align->record, parent, "record", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "align", 1);
}

void
sfi_attribs(nhfp, d_attribs, myparent, myname, cnt)
NHFILE *nhfp;
struct attribs *d_attribs;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "attribs";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "attribs", 1);

    sfi_schar(nhfp, d_attribs->a, parent, "a", A_MAX);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "attribs", 1);
}

void
sfi_bill_x(nhfp, d_bill_x, myparent, myname, cnt)
NHFILE *nhfp;
struct bill_x *d_bill_x;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "bill_x";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "bill_x", 1);

    sfi_unsigned(nhfp, &d_bill_x->bo_id, parent, "bo_id", 1);
    sfi_boolean(nhfp, &d_bill_x->useup, parent, "useup", 1);
    sfi_long(nhfp, &d_bill_x->price, parent, "price", 1);
    sfi_long(nhfp, &d_bill_x->bquan, parent, "bquan", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "bill_x", 1);
}

void
sfi_book_info(nhfp, d_book_info, myparent, myname, cnt)
NHFILE *nhfp;
struct book_info *d_book_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "book_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "book_info", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_book_info->book, parent, "book", 1);
    sfi_unsigned(nhfp, &d_book_info->o_id, parent, "o_id", 1);
    sfi_schar(nhfp, &d_book_info->delay, parent, "delay", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "book_info", 1);
}

void
sfi_branch(nhfp, d_branch, myparent, myname, cnt)
NHFILE *nhfp;
struct branch *d_branch;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "branch";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "branch", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_branch->next, parent, "next", 1);
    sfi_int(nhfp, &d_branch->id, parent, "id", 1);
    sfi_int(nhfp, &d_branch->type, parent, "type", 1);
    sfi_d_level(nhfp, &d_branch->end1, parent, "end1", 1);
    sfi_d_level(nhfp, &d_branch->end2, parent, "end2", 1);
    sfi_boolean(nhfp, &d_branch->end1_up, parent, "end1_up", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "branch", 1);
}

void
sfi_bubble(nhfp, d_bubble, myparent, myname, cnt)
NHFILE *nhfp;
struct bubble *d_bubble;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "bubble";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "bubble", 1);

    sfi_xchar(nhfp, &d_bubble->x, parent, "x", 1);
    sfi_xchar(nhfp, &d_bubble->y, parent, "y", 1);
    sfi_schar(nhfp, &d_bubble->dx, parent, "dx", 1);
    sfi_schar(nhfp, &d_bubble->dy, parent, "dy", 1);
    sfi_uchar(nhfp, d_bubble->bm, parent, "bm", MAX_BMASK + 2);
    sfi_genericptr(nhfp, (genericptr_t) &d_bubble->prev, parent, "prev", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_bubble->next, parent, "next", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_bubble->cons, parent, "cons", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "bubble", 1);
}

void
sfi_cemetery(nhfp, d_cemetery, myparent, myname, cnt)
NHFILE *nhfp;
struct cemetery *d_cemetery;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "cemetery";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "cemetery", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_cemetery->next, parent, "next", 1);
    sfi_char(nhfp, d_cemetery->who, parent, "who", PL_NSIZ + 4 * (1 + 3) + 1);
    sfi_char(nhfp, d_cemetery->how, parent, "how", 100 + 1);
    sfi_char(nhfp, d_cemetery->when, parent, "when", 4 + 2 + 2 + 2 + 2 + 2 + 1);
    sfi_schar(nhfp, &d_cemetery->frpx, parent, "frpx", 1);
    sfi_schar(nhfp, &d_cemetery->frpy, parent, "frpy", 1);
    sfi_boolean(nhfp, &d_cemetery->bonesknown, parent, "bonesknown", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "cemetery", 1);
}

void
sfi_context_info(nhfp, d_context_info, myparent, myname, cnt)
NHFILE *nhfp;
struct context_info *d_context_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "context_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "context_info", 1);

    sfi_unsigned(nhfp, &d_context_info->ident, parent, "ident", 1);
    sfi_unsigned(nhfp, &d_context_info->no_of_wizards, parent, "no_of_wizards", 1);
    sfi_unsigned(nhfp, &d_context_info->run, parent, "run", 1);
    sfi_unsigned(nhfp, &d_context_info->startingpet_mid, parent, "startingpet_mid", 1);
    sfi_int(nhfp, &d_context_info->current_fruit, parent, "current_fruit", 1);
    sfi_int(nhfp, &d_context_info->warnlevel, parent, "warnlevel", 1);
    sfi_int(nhfp, &d_context_info->rndencode, parent, "rndencode", 1);
    sfi_long(nhfp, &d_context_info->next_attrib_check, parent, "next_attrib_check", 1);
    sfi_long(nhfp, &d_context_info->stethoscope_move, parent, "stethoscope_move", 1);
    sfi_short(nhfp, &d_context_info->stethoscope_movement, parent, "stethoscope_movement", 1);
    sfi_boolean(nhfp, &d_context_info->travel, parent, "travel", 1);
    sfi_boolean(nhfp, &d_context_info->travel1, parent, "travel1", 1);
    sfi_boolean(nhfp, &d_context_info->forcefight, parent, "forcefight", 1);
    sfi_boolean(nhfp, &d_context_info->nopick, parent, "nopick", 1);
    sfi_boolean(nhfp, &d_context_info->made_amulet, parent, "made_amulet", 1);
    sfi_boolean(nhfp, &d_context_info->mon_moving, parent, "mon_moving", 1);
    sfi_boolean(nhfp, &d_context_info->move, parent, "move", 1);
    sfi_boolean(nhfp, &d_context_info->mv, parent, "mv", 1);
    sfi_boolean(nhfp, &d_context_info->bypasses, parent, "bypasses", 1);
    sfi_boolean(nhfp, &d_context_info->botl, parent, "botl", 1);
    sfi_boolean(nhfp, &d_context_info->botlx, parent, "botlx", 1);
    sfi_boolean(nhfp, &d_context_info->door_opened, parent, "door_opened", 1);
    sfi_dig_info(nhfp, &d_context_info->digging, parent, "digging", 1);
    sfi_victual_info(nhfp, &d_context_info->victual, parent, "victual", 1);
    sfi_tin_info(nhfp, &d_context_info->tin, parent, "tin", 1);
    sfi_book_info(nhfp, &d_context_info->spbook, parent, "spbook", 1);
    sfi_takeoff_info(nhfp, &d_context_info->takeoff, parent, "takeoff", 1);
    sfi_warntype_info(nhfp, &d_context_info->warntype, parent, "warntype", 1);
    sfi_polearm_info(nhfp, &d_context_info->polearm, parent, "polearm", 1);
    sfi_obj_split(nhfp, &d_context_info->objsplit, parent, "objsplit", 1);
    sfi_tribute_info(nhfp, &d_context_info->tribute, parent, "tribute", 1);
    sfi_novel_tracking(nhfp, &d_context_info->novel, parent, "novel", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "context_info", 1);
}

void
sfi_d_flags(nhfp, d_d_flags, myparent, myname, cnt)
NHFILE *nhfp;
struct d_flags *d_d_flags;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "d_flags";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "d_flags", 1);

    bitfield = d_d_flags->town;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "town",  1);
    d_d_flags->town = bitfield;

    bitfield = d_d_flags->hellish;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "hellish",  1);
    d_d_flags->hellish = bitfield;

    bitfield = d_d_flags->maze_like;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "maze_like",  1);
    d_d_flags->maze_like = bitfield;

    bitfield = d_d_flags->rogue_like;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "rogue_like",  1);
    d_d_flags->rogue_like = bitfield;

    bitfield = d_d_flags->align;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "align",  3);
    d_d_flags->align = bitfield;

    bitfield = d_d_flags->unused;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "unused",  1);
    d_d_flags->unused = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "d_flags", 1);
}

void
sfi_d_level(nhfp, d_d_level, myparent, myname, cnt)
NHFILE *nhfp;
struct d_level *d_d_level;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "d_level";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "d_level", 1);

    sfi_xchar(nhfp, &d_d_level->dnum, parent, "dnum", 1);
    sfi_xchar(nhfp, &d_d_level->dlevel, parent, "dlevel", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "d_level", 1);
}

void
sfi_damage(nhfp, d_damage, myparent, myname, cnt)
NHFILE *nhfp;
struct damage *d_damage;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "damage";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "damage", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_damage->next, parent, "next", 1);
    sfi_long(nhfp, &d_damage->when, parent, "when", 1);
    sfi_long(nhfp, &d_damage->cost, parent, "cost", 1);
    sfi_nhcoord(nhfp, &d_damage->place, parent, "place", 1);
    sfi_schar(nhfp, &d_damage->typ, parent, "typ", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "damage", 1);
}

void
sfi_dest_area(nhfp, d_dest_area, myparent, myname, cnt)
NHFILE *nhfp;
struct dest_area *d_dest_area;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "dest_area";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "dest_area", 1);

    sfi_xchar(nhfp, &d_dest_area->lx, parent, "lx", 1);
    sfi_xchar(nhfp, &d_dest_area->ly, parent, "ly", 1);
    sfi_xchar(nhfp, &d_dest_area->hx, parent, "hx", 1);
    sfi_xchar(nhfp, &d_dest_area->hy, parent, "hy", 1);
    sfi_xchar(nhfp, &d_dest_area->nlx, parent, "nlx", 1);
    sfi_xchar(nhfp, &d_dest_area->nly, parent, "nly", 1);
    sfi_xchar(nhfp, &d_dest_area->nhx, parent, "nhx", 1);
    sfi_xchar(nhfp, &d_dest_area->nhy, parent, "nhy", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "dest_area", 1);
}

void
sfi_dgn_topology(nhfp, d_dgn_topology, myparent, myname, cnt)
NHFILE *nhfp;
struct dgn_topology *d_dgn_topology;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "dgn_topology";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "dgn_topology", 1);

    sfi_d_level(nhfp, &d_dgn_topology->d_oracle_level, parent, "d_oracle_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_bigroom_level, parent, "d_bigroom_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_rogue_level, parent, "d_rogue_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_medusa_level, parent, "d_medusa_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_stronghold_level, parent, "d_stronghold_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_valley_level, parent, "d_valley_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_wiz1_level, parent, "d_wiz1_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_wiz2_level, parent, "d_wiz2_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_wiz3_level, parent, "d_wiz3_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_juiblex_level, parent, "d_juiblex_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_orcus_level, parent, "d_orcus_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_baalzebub_level, parent, "d_baalzebub_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_asmodeus_level, parent, "d_asmodeus_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_portal_level, parent, "d_portal_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_sanctum_level, parent, "d_sanctum_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_earth_level, parent, "d_earth_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_water_level, parent, "d_water_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_fire_level, parent, "d_fire_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_air_level, parent, "d_air_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_astral_level, parent, "d_astral_level", 1);
    sfi_xchar(nhfp, &d_dgn_topology->d_tower_dnum, parent, "d_tower_dnum", 1);
    sfi_xchar(nhfp, &d_dgn_topology->d_sokoban_dnum, parent, "d_sokoban_dnum", 1);
    sfi_xchar(nhfp, &d_dgn_topology->d_mines_dnum, parent, "d_mines_dnum", 1);
    sfi_xchar(nhfp, &d_dgn_topology->d_quest_dnum, parent, "d_quest_dnum", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_qstart_level, parent, "d_qstart_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_qlocate_level, parent, "d_qlocate_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_nemesis_level, parent, "d_nemesis_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_knox_level, parent, "d_knox_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_mineend_level, parent, "d_mineend_level", 1);
    sfi_d_level(nhfp, &d_dgn_topology->d_sokoend_level, parent, "d_sokoend_level", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "dgn_topology", 1);
}

void
sfi_dig_info(nhfp, d_dig_info, myparent, myname, cnt)
NHFILE *nhfp;
struct dig_info *d_dig_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "dig_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "dig_info", 1);

    sfi_int(nhfp, &d_dig_info->effort, parent, "effort", 1);
    sfi_d_level(nhfp, &d_dig_info->level, parent, "level", 1);
    sfi_nhcoord(nhfp, &d_dig_info->pos, parent, "pos", 1);
    sfi_long(nhfp, &d_dig_info->lastdigtime, parent, "lastdigtime", 1);
    sfi_boolean(nhfp, &d_dig_info->down, parent, "down", 1);
    sfi_boolean(nhfp, &d_dig_info->chew, parent, "chew", 1);
    sfi_boolean(nhfp, &d_dig_info->warned, parent, "warned", 1);
    sfi_boolean(nhfp, &d_dig_info->quiet, parent, "quiet", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "dig_info", 1);
}

void
sfi_dungeon(nhfp, d_dungeon, myparent, myname, cnt)
NHFILE *nhfp;
struct dungeon *d_dungeon;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "dungeon";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "dungeon", 1);

    sfi_char(nhfp, d_dungeon->dname, parent, "dname", 24);
    sfi_char(nhfp, d_dungeon->proto, parent, "proto", 15);
    sfi_char(nhfp, &d_dungeon->boneid, parent, "boneid", 1);
    sfi_d_flags(nhfp, &d_dungeon->flags, parent, "flags", 1);
    sfi_xchar(nhfp, &d_dungeon->entry_lev, parent, "entry_lev", 1);
    sfi_xchar(nhfp, &d_dungeon->num_dunlevs, parent, "num_dunlevs", 1);
    sfi_xchar(nhfp, &d_dungeon->dunlev_ureached, parent, "dunlev_ureached", 1);
    sfi_int(nhfp, &d_dungeon->ledger_start, parent, "ledger_start", 1);
    sfi_int(nhfp, &d_dungeon->depth_start, parent, "depth_start", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "dungeon", 1);
}

void
sfi_edog(nhfp, d_edog, myparent, myname, cnt)
NHFILE *nhfp;
struct edog *d_edog;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "edog";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "edog", 1);

    sfi_long(nhfp, &d_edog->droptime, parent, "droptime", 1);
    sfi_unsigned(nhfp, &d_edog->dropdist, parent, "dropdist", 1);
    sfi_int(nhfp, &d_edog->apport, parent, "apport", 1);
    sfi_long(nhfp, &d_edog->whistletime, parent, "whistletime", 1);
    sfi_long(nhfp, &d_edog->hungrytime, parent, "hungrytime", 1);
    sfi_nhcoord(nhfp, &d_edog->ogoal, parent, "ogoal", 1);
    sfi_int(nhfp, &d_edog->abuse, parent, "abuse", 1);
    sfi_int(nhfp, &d_edog->revivals, parent, "revivals", 1);
    sfi_int(nhfp, &d_edog->mhpmax_penalty, parent, "mhpmax_penalty", 1);
    bitfield = d_edog->killed_by_u;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "killed_by_u",  1);
    d_edog->killed_by_u = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "edog", 1);
}

void
sfi_egd(nhfp, d_egd, myparent, myname, cnt)
NHFILE *nhfp;
struct egd *d_egd;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "egd";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "egd", 1);

    sfi_int(nhfp, &d_egd->fcbeg, parent, "fcbeg", 1);
    sfi_int(nhfp, &d_egd->fcend, parent, "fcend", 1);
    sfi_int(nhfp, &d_egd->vroom, parent, "vroom", 1);
    sfi_xchar(nhfp, &d_egd->gdx, parent, "gdx", 1);
    sfi_xchar(nhfp, &d_egd->gdy, parent, "gdy", 1);
    sfi_xchar(nhfp, &d_egd->ogx, parent, "ogx", 1);
    sfi_xchar(nhfp, &d_egd->ogy, parent, "ogy", 1);
    sfi_d_level(nhfp, &d_egd->gdlevel, parent, "gdlevel", 1);
    sfi_xchar(nhfp, &d_egd->warncnt, parent, "warncnt", 1);
    bitfield = d_egd->gddone;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "gddone",  1);
    d_egd->gddone = bitfield;

    bitfield = d_egd->witness;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "witness",  2);
    d_egd->witness = bitfield;

    bitfield = d_egd->unused;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "unused",  5);
    d_egd->unused = bitfield;

    for (i = 0; i < FCSIZ; ++i)
        sfi_fakecorridor(nhfp, &d_egd->fakecorr[i], parent, "fakecorr", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "egd", 1);
}

void
sfi_emin(nhfp, d_emin, myparent, myname, cnt)
NHFILE *nhfp;
struct emin *d_emin;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "emin";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "emin", 1);

    sfi_aligntyp(nhfp, &d_emin->min_align, parent, "min_align", 1);
    sfi_boolean(nhfp, &d_emin->renegade, parent, "renegade", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "emin", 1);
}

void
sfi_engr(nhfp, d_engr, myparent, myname, cnt)
NHFILE *nhfp;
struct engr *d_engr;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "engr";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "engr", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_engr->nxt_engr, parent, "nxt_engr", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_engr->engr_txt, parent, "engr_txt", 1);
    sfi_xchar(nhfp, &d_engr->engr_x, parent, "engr_x", 1);
    sfi_xchar(nhfp, &d_engr->engr_y, parent, "engr_y", 1);
    sfi_unsigned(nhfp, &d_engr->engr_lth, parent, "engr_lth", 1);
    sfi_long(nhfp, &d_engr->engr_time, parent, "engr_time", 1);
    sfi_xchar(nhfp, &d_engr->engr_type, parent, "engr_type", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "engr", 1);
}

void
sfi_epri(nhfp, d_epri, myparent, myname, cnt)
NHFILE *nhfp;
struct epri *d_epri;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "epri";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "epri", 1);

    sfi_aligntyp(nhfp, &d_epri->shralign, parent, "shralign", 1);
    sfi_schar(nhfp, &d_epri->shroom, parent, "shroom", 1);
    sfi_nhcoord(nhfp, &d_epri->shrpos, parent, "shrpos", 1);
    sfi_d_level(nhfp, &d_epri->shrlevel, parent, "shrlevel", 1);
    sfi_long(nhfp, &d_epri->intone_time, parent, "intone_time", 1);
    sfi_long(nhfp, &d_epri->enter_time, parent, "enter_time", 1);
    sfi_long(nhfp, &d_epri->hostile_time, parent, "hostile_time", 1);
    sfi_long(nhfp, &d_epri->peaceful_time, parent, "peaceful_time", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "epri", 1);
}

void
sfi_eshk(nhfp, d_eshk, myparent, myname, cnt)
NHFILE *nhfp;
struct eshk *d_eshk;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "eshk";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "eshk", 1);

    sfi_long(nhfp, &d_eshk->robbed, parent, "robbed", 1);
    sfi_long(nhfp, &d_eshk->credit, parent, "credit", 1);
    sfi_long(nhfp, &d_eshk->debit, parent, "debit", 1);
    sfi_long(nhfp, &d_eshk->loan, parent, "loan", 1);
    sfi_int(nhfp, &d_eshk->shoptype, parent, "shoptype", 1);
    sfi_schar(nhfp, &d_eshk->shoproom, parent, "shoproom", 1);
    sfi_schar(nhfp, &d_eshk->unused, parent, "unused", 1);
    sfi_boolean(nhfp, &d_eshk->following, parent, "following", 1);
    sfi_boolean(nhfp, &d_eshk->surcharge, parent, "surcharge", 1);
    sfi_boolean(nhfp, &d_eshk->dismiss_kops, parent, "dismiss_kops", 1);
    sfi_nhcoord(nhfp, &d_eshk->shk, parent, "shk", 1);
    sfi_nhcoord(nhfp, &d_eshk->shd, parent, "shd", 1);
    sfi_d_level(nhfp, &d_eshk->shoplevel, parent, "shoplevel", 1);
    sfi_int(nhfp, &d_eshk->billct, parent, "billct", 1);
    for (i = 0; i < BILLSZ; ++i)
        sfi_bill_x(nhfp, &d_eshk->bill[i], parent, "bill", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_eshk->bill_p, parent, "bill_p", 1);
    sfi_int(nhfp, &d_eshk->visitct, parent, "visitct", 1);
    sfi_char(nhfp, d_eshk->customer, parent, "customer", PL_NSIZ);
    sfi_char(nhfp, d_eshk->shknam, parent, "shknam", PL_NSIZ);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "eshk", 1);
}

void
sfi_fakecorridor(nhfp, d_fakecorridor, myparent, myname, cnt)
NHFILE *nhfp;
struct fakecorridor *d_fakecorridor;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "fakecorridor";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "fakecorridor", 1);

    sfi_xchar(nhfp, &d_fakecorridor->fx, parent, "fx", 1);
    sfi_xchar(nhfp, &d_fakecorridor->fy, parent, "fy", 1);
    sfi_xchar(nhfp, &d_fakecorridor->ftyp, parent, "ftyp", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "fakecorridor", 1);
}

void
sfi_fe(nhfp, d_fe, myparent, myname, cnt)
NHFILE *nhfp;
struct fe *d_fe;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "fe";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "fe", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_fe->next, parent, "next", 1);
    sfi_long(nhfp, &d_fe->timeout, parent, "timeout", 1);
    sfi_ulong(nhfp, &d_fe->tid, parent, "tid", 1);
    sfi_short(nhfp, &d_fe->kind, parent, "kind", 1);
    sfi_short(nhfp, &d_fe->func_index, parent, "func_index", 1);
    sfi_any(nhfp, &d_fe->arg, parent, "arg", 1);
    bitfield = d_fe->needs_fixup;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "needs_fixup",  1);
    d_fe->needs_fixup = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "fe", 1);
}

void
sfi_flag(nhfp, d_flag, myparent, myname, cnt)
NHFILE *nhfp;
struct flag *d_flag;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "flag";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "flag", 1);

    sfi_boolean(nhfp, &d_flag->acoustics, parent, "acoustics", 1);
    sfi_boolean(nhfp, &d_flag->autodig, parent, "autodig", 1);
    sfi_boolean(nhfp, &d_flag->autoquiver, parent, "autoquiver", 1);
    sfi_boolean(nhfp, &d_flag->autoopen, parent, "autoopen", 1);
    sfi_boolean(nhfp, &d_flag->beginner, parent, "beginner", 1);
    sfi_boolean(nhfp, &d_flag->biff, parent, "biff", 1);
    sfi_boolean(nhfp, &d_flag->bones, parent, "bones", 1);
    sfi_boolean(nhfp, &d_flag->confirm, parent, "confirm", 1);
    sfi_boolean(nhfp, &d_flag->dark_room, parent, "dark_room", 1);
    sfi_boolean(nhfp, &d_flag->debug, parent, "debug", 1);
    sfi_boolean(nhfp, &d_flag->end_own, parent, "end_own", 1);
    sfi_boolean(nhfp, &d_flag->explore, parent, "explore", 1);
    sfi_boolean(nhfp, &d_flag->female, parent, "female", 1);
    sfi_boolean(nhfp, &d_flag->friday13, parent, "friday13", 1);
    sfi_boolean(nhfp, &d_flag->help, parent, "help", 1);
    sfi_boolean(nhfp, &d_flag->ignintr, parent, "ignintr", 1);
    sfi_boolean(nhfp, &d_flag->ins_chkpt, parent, "ins_chkpt", 1);
    sfi_boolean(nhfp, &d_flag->invlet_constant, parent, "invlet_constant", 1);
    sfi_boolean(nhfp, &d_flag->legacy, parent, "legacy", 1);
    sfi_boolean(nhfp, &d_flag->lit_corridor, parent, "lit_corridor", 1);
    sfi_boolean(nhfp, &d_flag->nap, parent, "nap", 1);
    sfi_boolean(nhfp, &d_flag->null, parent, "null", 1);
    sfi_boolean(nhfp, &d_flag->p__obsolete, parent, "p__obsolete", 1);
    sfi_boolean(nhfp, &d_flag->pickup, parent, "pickup", 1);
    sfi_boolean(nhfp, &d_flag->pickup_thrown, parent, "pickup_thrown", 1);
    sfi_boolean(nhfp, &d_flag->pushweapon, parent, "pushweapon", 1);
    sfi_boolean(nhfp, &d_flag->rest_on_space, parent, "rest_on_space", 1);
    sfi_boolean(nhfp, &d_flag->safe_dog, parent, "safe_dog", 1);
    sfi_boolean(nhfp, &d_flag->showexp, parent, "showexp", 1);
    sfi_boolean(nhfp, &d_flag->showscore, parent, "showscore", 1);
    sfi_boolean(nhfp, &d_flag->silent, parent, "silent", 1);
    sfi_boolean(nhfp, &d_flag->sortpack, parent, "sortpack", 1);
    sfi_boolean(nhfp, &d_flag->sparkle, parent, "sparkle", 1);
    sfi_boolean(nhfp, &d_flag->standout, parent, "standout", 1);
    sfi_boolean(nhfp, &d_flag->time, parent, "time", 1);
    sfi_boolean(nhfp, &d_flag->tombstone, parent, "tombstone", 1);
    sfi_boolean(nhfp, &d_flag->verbose, parent, "verbose", 1);
    sfi_int(nhfp, &d_flag->end_top, parent, "end_top", 1);
    sfi_int(nhfp, &d_flag->end_around, parent, "end_around", 1);
    sfi_unsigned(nhfp, &d_flag->moonphase, parent, "moonphase", 1);
    sfi_ulong(nhfp, &d_flag->suppress_alert, parent, "suppress_alert", 1);
    sfi_unsigned(nhfp, &d_flag->paranoia_bits, parent, "paranoia_bits", 1);
    sfi_int(nhfp, &d_flag->pickup_burden, parent, "pickup_burden", 1);
    sfi_int(nhfp, &d_flag->pile_limit, parent, "pile_limit", 1);
    sfi_char(nhfp, &d_flag->sortloot, parent, "sortloot", 1);
    sfi_char(nhfp, d_flag->inv_order, parent, "inv_order", MAXOCLASSES);
    sfi_char(nhfp, d_flag->pickup_types, parent, "pickup_types", MAXOCLASSES);
    sfi_char(nhfp, d_flag->end_disclose, parent, "end_disclose", NUM_DISCLOSURE_OPTIONS + 1);
    sfi_char(nhfp, &d_flag->menu_style, parent, "menu_style", 1);
    sfi_boolean(nhfp, &d_flag->made_fruit, parent, "made_fruit", 1);
    sfi_int(nhfp, &d_flag->initrole, parent, "initrole", 1);
    sfi_int(nhfp, &d_flag->initrace, parent, "initrace", 1);
    sfi_int(nhfp, &d_flag->initgend, parent, "initgend", 1);
    sfi_int(nhfp, &d_flag->initalign, parent, "initalign", 1);
    sfi_int(nhfp, &d_flag->randomall, parent, "randomall", 1);
    sfi_int(nhfp, &d_flag->pantheon, parent, "pantheon", 1);
    sfi_boolean(nhfp, &d_flag->lootabc, parent, "lootabc", 1);
    sfi_boolean(nhfp, &d_flag->showrace, parent, "showrace", 1);
    sfi_boolean(nhfp, &d_flag->travelcmd, parent, "travelcmd", 1);
    sfi_int(nhfp, &d_flag->runmode, parent, "runmode", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "flag", 1);
}

void
sfi_fruit(nhfp, d_fruit, myparent, myname, cnt)
NHFILE *nhfp;
struct fruit *d_fruit;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "fruit";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "fruit", 1);

    sfi_char(nhfp, d_fruit->fname, parent, "fname", PL_FSIZ);
    sfi_int(nhfp, &d_fruit->fid, parent, "fid", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_fruit->nextf, parent, "nextf", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "fruit", 1);
}

void
sfi_kinfo(nhfp, d_kinfo, myparent, myname, cnt)
NHFILE *nhfp;
struct kinfo *d_kinfo;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "kinfo";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "kinfo", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_kinfo->next, parent, "next", 1);
    sfi_int(nhfp, &d_kinfo->id, parent, "id", 1);
    sfi_int(nhfp, &d_kinfo->format, parent, "format", 1);
    sfi_char(nhfp, d_kinfo->name, parent, "name", BUFSZ);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "kinfo", 1);
}

void
sfi_levelflags(nhfp, d_levelflags, myparent, myname, cnt)
NHFILE *nhfp;
struct levelflags *d_levelflags;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "levelflags";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "levelflags", 1);

    sfi_uchar(nhfp, &d_levelflags->nfountains, parent, "nfountains", 1);
    sfi_uchar(nhfp, &d_levelflags->nsinks, parent, "nsinks", 1);
    bitfield = d_levelflags->has_shop;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_shop",  1);
    d_levelflags->has_shop = bitfield;

    bitfield = d_levelflags->has_vault;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_vault",  1);
    d_levelflags->has_vault = bitfield;

    bitfield = d_levelflags->has_zoo;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_zoo",  1);
    d_levelflags->has_zoo = bitfield;

    bitfield = d_levelflags->has_court;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_court",  1);
    d_levelflags->has_court = bitfield;

    bitfield = d_levelflags->has_morgue;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_morgue",  1);
    d_levelflags->has_morgue = bitfield;

    bitfield = d_levelflags->has_beehive;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_beehive",  1);
    d_levelflags->has_beehive = bitfield;

    bitfield = d_levelflags->has_barracks;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_barracks",  1);
    d_levelflags->has_barracks = bitfield;

    bitfield = d_levelflags->has_temple;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_temple",  1);
    d_levelflags->has_temple = bitfield;

    bitfield = d_levelflags->has_swamp;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "has_swamp",  1);
    d_levelflags->has_swamp = bitfield;

    bitfield = d_levelflags->noteleport;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "noteleport",  1);
    d_levelflags->noteleport = bitfield;

    bitfield = d_levelflags->hardfloor;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "hardfloor",  1);
    d_levelflags->hardfloor = bitfield;

    bitfield = d_levelflags->nommap;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "nommap",  1);
    d_levelflags->nommap = bitfield;

    bitfield = d_levelflags->hero_memory;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "hero_memory",  1);
    d_levelflags->hero_memory = bitfield;

    bitfield = d_levelflags->shortsighted;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "shortsighted",  1);
    d_levelflags->shortsighted = bitfield;

    bitfield = d_levelflags->graveyard;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "graveyard",  1);
    d_levelflags->graveyard = bitfield;

    bitfield = d_levelflags->sokoban_rules;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "sokoban_rules",  1);
    d_levelflags->sokoban_rules = bitfield;

    bitfield = d_levelflags->is_maze_lev;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "is_maze_lev",  1);
    d_levelflags->is_maze_lev = bitfield;

    bitfield = d_levelflags->is_cavernous_lev;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "is_cavernous_lev",  1);
    d_levelflags->is_cavernous_lev = bitfield;

    bitfield = d_levelflags->arboreal;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "arboreal",  1);
    d_levelflags->arboreal = bitfield;

    bitfield = d_levelflags->wizard_bones;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "wizard_bones",  1);
    d_levelflags->wizard_bones = bitfield;

    bitfield = d_levelflags->corrmaze;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "corrmaze",  1);
    d_levelflags->corrmaze = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "levelflags", 1);
}

void
sfi_linfo(nhfp, d_linfo, myparent, myname, cnt)
NHFILE *nhfp;
struct linfo *d_linfo;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "linfo";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "linfo", 1);

    sfi_uchar(nhfp, &d_linfo->flags, parent, "flags", 1);
#ifdef MFLOPPY
    sfi_int(nhfp, &d_linfo->where, parent, "where", 1);
    sfi_long(nhfp, &d_linfo->time, parent, "time", 1);
    sfi_long(nhfp, &d_linfo->size, parent, "size", 1);
#endif /*MFLOPPY*/

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "linfo", 1);
}

void
sfi_ls_t(nhfp, d_ls_t, myparent, myname, cnt)
NHFILE *nhfp;
struct ls_t *d_ls_t;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "ls_t";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "ls_t", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_ls_t->next, parent, "next", 1);
    sfi_xchar(nhfp, &d_ls_t->x, parent, "x", 1);
    sfi_xchar(nhfp, &d_ls_t->y, parent, "y", 1);
    sfi_short(nhfp, &d_ls_t->range, parent, "range", 1);
    sfi_short(nhfp, &d_ls_t->flags, parent, "flags", 1);
    sfi_short(nhfp, &d_ls_t->type, parent, "type", 1);
    sfi_any(nhfp, &d_ls_t->id, parent, "id", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "ls_t", 1);
}

void
sfi_mapseen_feat(nhfp, d_mapseen_feat, myparent, myname, cnt)
NHFILE *nhfp;
struct mapseen_feat *d_mapseen_feat;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mapseen_feat";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "mapseen_feat", 1);

    bitfield = d_mapseen_feat->nfount;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "nfount",  2);
    d_mapseen_feat->nfount = bitfield;

    bitfield = d_mapseen_feat->nsink;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "nsink",  2);
    d_mapseen_feat->nsink = bitfield;

    bitfield = d_mapseen_feat->naltar;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "naltar",  2);
    d_mapseen_feat->naltar = bitfield;

    bitfield = d_mapseen_feat->nthrone;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "nthrone",  2);
    d_mapseen_feat->nthrone = bitfield;

    bitfield = d_mapseen_feat->ngrave;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ngrave",  2);
    d_mapseen_feat->ngrave = bitfield;

    bitfield = d_mapseen_feat->ntree;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ntree",  2);
    d_mapseen_feat->ntree = bitfield;

    bitfield = d_mapseen_feat->water;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "water",  2);
    d_mapseen_feat->water = bitfield;

    bitfield = d_mapseen_feat->lava;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "lava",  2);
    d_mapseen_feat->lava = bitfield;

    bitfield = d_mapseen_feat->ice;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ice",  2);
    d_mapseen_feat->ice = bitfield;

    bitfield = d_mapseen_feat->nshop;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "nshop",  2);
    d_mapseen_feat->nshop = bitfield;

    bitfield = d_mapseen_feat->ntemple;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ntemple",  2);
    d_mapseen_feat->ntemple = bitfield;

    bitfield = d_mapseen_feat->msalign;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "msalign",  2);
    d_mapseen_feat->msalign = bitfield;

    bitfield = d_mapseen_feat->shoptype;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "shoptype",  5);
    d_mapseen_feat->shoptype = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "mapseen_feat", 1);
}

void
sfi_mapseen_flags(nhfp, d_mapseen_flags, myparent, myname, cnt)
NHFILE *nhfp;
struct mapseen_flags *d_mapseen_flags;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mapseen_flags";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "mapseen_flags", 1);

    bitfield = d_mapseen_flags->unreachable;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "unreachable",  1);
    d_mapseen_flags->unreachable = bitfield;

    bitfield = d_mapseen_flags->forgot;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "forgot",  1);
    d_mapseen_flags->forgot = bitfield;

    bitfield = d_mapseen_flags->knownbones;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "knownbones",  1);
    d_mapseen_flags->knownbones = bitfield;

    bitfield = d_mapseen_flags->oracle;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oracle",  1);
    d_mapseen_flags->oracle = bitfield;

    bitfield = d_mapseen_flags->sokosolved;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "sokosolved",  1);
    d_mapseen_flags->sokosolved = bitfield;

    bitfield = d_mapseen_flags->bigroom;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "bigroom",  1);
    d_mapseen_flags->bigroom = bitfield;

    bitfield = d_mapseen_flags->castle;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "castle",  1);
    d_mapseen_flags->castle = bitfield;

    bitfield = d_mapseen_flags->castletune;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "castletune",  1);
    d_mapseen_flags->castletune = bitfield;

    bitfield = d_mapseen_flags->valley;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "valley",  1);
    d_mapseen_flags->valley = bitfield;

    bitfield = d_mapseen_flags->msanctum;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "msanctum",  1);
    d_mapseen_flags->msanctum = bitfield;

    bitfield = d_mapseen_flags->ludios;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ludios",  1);
    d_mapseen_flags->ludios = bitfield;

    bitfield = d_mapseen_flags->roguelevel;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "roguelevel",  1);
    d_mapseen_flags->roguelevel = bitfield;

    bitfield = d_mapseen_flags->quest_summons;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "quest_summons",  1);
    d_mapseen_flags->quest_summons = bitfield;

    bitfield = d_mapseen_flags->questing;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "questing",  1);
    d_mapseen_flags->questing = bitfield;

    bitfield = d_mapseen_flags->vibrating_square;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "vibrating_square",  1);
    d_mapseen_flags->vibrating_square = bitfield;

    bitfield = d_mapseen_flags->spare1;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "spare1",  1);
    d_mapseen_flags->spare1 = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "mapseen_flags", 1);
}

void
sfi_mapseen_rooms(nhfp, d_mapseen_rooms, myparent, myname, cnt)
NHFILE *nhfp;
struct mapseen_rooms *d_mapseen_rooms;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mapseen_rooms";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "mapseen_rooms", 1);

    bitfield = d_mapseen_rooms->seen;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "seen",  1);
    d_mapseen_rooms->seen = bitfield;

    bitfield = d_mapseen_rooms->untended;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "untended",  1);
    d_mapseen_rooms->untended = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "mapseen_rooms", 1);
}

void
sfi_mapseen(nhfp, d_mapseen, myparent, myname, cnt)
NHFILE *nhfp;
struct mapseen *d_mapseen;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mapseen";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "mapseen", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_mapseen->next, parent, "next", 1);
    sfi_branch(nhfp, d_mapseen->br, parent, "br", 1);
    sfi_d_level(nhfp, &d_mapseen->lev, parent, "lev", 1);
    sfi_mapseen_feat(nhfp, &d_mapseen->feat, parent, "feat", 1);
    sfi_mapseen_flags(nhfp, &d_mapseen->flags, parent, "flags", 1);
    sfi_char(nhfp, d_mapseen->custom, parent, "custom", 1);
    sfi_unsigned(nhfp, &d_mapseen->custom_lth, parent, "custom_lth", 1);
    for (i = 0; i < (MAXNROFROOMS + 1) * 2; ++i)
        sfi_mapseen_rooms(nhfp, &d_mapseen->msrooms[i], parent, "msrooms", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_mapseen->final_resting_place, parent, "final_resting_place", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "mapseen", 1);
}

void
sfi_mextra(nhfp, d_mextra, myparent, myname, cnt)
NHFILE *nhfp;
struct mextra *d_mextra;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mextra";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "mextra", 1);

    sfi_char(nhfp, d_mextra->mname, parent, "mname", 1);
    sfi_egd(nhfp, d_mextra->egd, parent, "egd", 1);
    sfi_epri(nhfp, d_mextra->epri, parent, "epri", 1);
    sfi_eshk(nhfp, d_mextra->eshk, parent, "eshk", 1);
    sfi_emin(nhfp, d_mextra->emin, parent, "emin", 1);
    sfi_edog(nhfp, d_mextra->edog, parent, "edog", 1);
    sfi_int(nhfp, &d_mextra->mcorpsenm, parent, "mcorpsenm", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "mextra", 1);
}

void
sfi_mkroom(nhfp, d_mkroom, myparent, myname, cnt)
NHFILE *nhfp;
struct mkroom *d_mkroom;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mkroom";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "mkroom", 1);

    sfi_schar(nhfp, &d_mkroom->lx, parent, "lx", 1);
    sfi_schar(nhfp, &d_mkroom->hx, parent, "hx", 1);
    sfi_schar(nhfp, &d_mkroom->ly, parent, "ly", 1);
    sfi_schar(nhfp, &d_mkroom->hy, parent, "hy", 1);
    sfi_schar(nhfp, &d_mkroom->rtype, parent, "rtype", 1);
    sfi_schar(nhfp, &d_mkroom->orig_rtype, parent, "orig_rtype", 1);
    sfi_schar(nhfp, &d_mkroom->rlit, parent, "rlit", 1);
    sfi_schar(nhfp, &d_mkroom->needfill, parent, "needfill", 1);
    sfi_schar(nhfp, &d_mkroom->needjoining, parent, "needjoining", 1);
    sfi_schar(nhfp, &d_mkroom->doorct, parent, "doorct", 1);
    sfi_schar(nhfp, &d_mkroom->fdoor, parent, "fdoor", 1);
    sfi_schar(nhfp, &d_mkroom->nsubrooms, parent, "nsubrooms", 1);
    sfi_boolean(nhfp, &d_mkroom->irregular, parent, "irregular", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_mkroom->sbrooms[0], parent, "sbrooms", MAX_SUBROOMS);
    sfi_genericptr(nhfp, (genericptr_t) &d_mkroom->resident, parent, "resident", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "mkroom", 1);
}

void
sfi_monst(nhfp, d_monst, myparent, myname, cnt)
NHFILE *nhfp;
struct monst *d_monst;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "monst";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "monst", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_monst->nmon, parent, "nmon", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_monst->data, parent, "data", 1);
    sfi_unsigned(nhfp, &d_monst->m_id, parent, "m_id", 1);
    sfi_short(nhfp, &d_monst->mnum, parent, "mnum", 1);
    sfi_short(nhfp, &d_monst->cham, parent, "cham", 1);
    sfi_short(nhfp, &d_monst->movement, parent, "movement", 1);
    sfi_uchar(nhfp, &d_monst->m_lev, parent, "m_lev", 1);
    sfi_aligntyp(nhfp, &d_monst->malign, parent, "malign", 1);
    sfi_xchar(nhfp, &d_monst->mx, parent, "mx", 1);
    sfi_xchar(nhfp, &d_monst->my, parent, "my", 1);
    sfi_xchar(nhfp, &d_monst->mux, parent, "mux", 1);
    sfi_xchar(nhfp, &d_monst->muy, parent, "muy", 1);
    for (i = 0; i < MTSZ; ++i)
        sfi_nhcoord(nhfp, &d_monst->mtrack[i], parent, "mtrack", 1);
    sfi_int(nhfp, &d_monst->mhp, parent, "mhp", 1);
    sfi_int(nhfp, &d_monst->mhpmax, parent, "mhpmax", 1);
    sfi_unsigned(nhfp, &d_monst->mappearance, parent, "mappearance", 1);
    sfi_uchar(nhfp, &d_monst->m_ap_type, parent, "m_ap_type", 1);
    sfi_schar(nhfp, &d_monst->mtame, parent, "mtame", 1);
    sfi_ushort(nhfp, &d_monst->mextrinsics, parent, "mextrinsics", 1);
    sfi_int(nhfp, &d_monst->mspec_used, parent, "mspec_used", 1);
    bitfield = d_monst->female;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "female",  1);
    d_monst->female = bitfield;

    bitfield = d_monst->minvis;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "minvis",  1);
    d_monst->minvis = bitfield;

    bitfield = d_monst->invis_blkd;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "invis_blkd",  1);
    d_monst->invis_blkd = bitfield;

    bitfield = d_monst->perminvis;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "perminvis",  1);
    d_monst->perminvis = bitfield;

    bitfield = d_monst->mcan;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mcan",  1);
    d_monst->mcan = bitfield;

    bitfield = d_monst->mburied;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mburied",  1);
    d_monst->mburied = bitfield;

    bitfield = d_monst->mundetected;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mundetected",  1);
    d_monst->mundetected = bitfield;

    bitfield = d_monst->mcansee;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mcansee",  1);
    d_monst->mcansee = bitfield;

    bitfield = d_monst->mspeed;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mspeed",  2);
    d_monst->mspeed = bitfield;

    bitfield = d_monst->permspeed;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "permspeed",  2);
    d_monst->permspeed = bitfield;

    bitfield = d_monst->mrevived;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mrevived",  1);
    d_monst->mrevived = bitfield;

    bitfield = d_monst->mcloned;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mcloned",  1);
    d_monst->mcloned = bitfield;

    bitfield = d_monst->mavenge;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mavenge",  1);
    d_monst->mavenge = bitfield;

    bitfield = d_monst->mflee;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mflee",  1);
    d_monst->mflee = bitfield;

    bitfield = d_monst->mfleetim;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mfleetim",  7);
    d_monst->mfleetim = bitfield;

    bitfield = d_monst->msleeping;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "msleeping",  1);
    d_monst->msleeping = bitfield;

    bitfield = d_monst->mblinded;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mblinded",  7);
    d_monst->mblinded = bitfield;

    bitfield = d_monst->mstun;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mstun",  1);
    d_monst->mstun = bitfield;

    bitfield = d_monst->mfrozen;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mfrozen",  7);
    d_monst->mfrozen = bitfield;

    bitfield = d_monst->mcanmove;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mcanmove",  1);
    d_monst->mcanmove = bitfield;

    bitfield = d_monst->mconf;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mconf",  1);
    d_monst->mconf = bitfield;

    bitfield = d_monst->mpeaceful;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mpeaceful",  1);
    d_monst->mpeaceful = bitfield;

    bitfield = d_monst->mtrapped;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mtrapped",  1);
    d_monst->mtrapped = bitfield;

    bitfield = d_monst->mleashed;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mleashed",  1);
    d_monst->mleashed = bitfield;

    bitfield = d_monst->isshk;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "isshk",  1);
    d_monst->isshk = bitfield;

    bitfield = d_monst->isminion;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "isminion",  1);
    d_monst->isminion = bitfield;

    bitfield = d_monst->isgd;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "isgd",  1);
    d_monst->isgd = bitfield;

    bitfield = d_monst->ispriest;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ispriest",  1);
    d_monst->ispriest = bitfield;

    bitfield = d_monst->iswiz;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "iswiz",  1);
    d_monst->iswiz = bitfield;

    bitfield = d_monst->wormno;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "wormno",  5);
    d_monst->wormno = bitfield;

    bitfield = d_monst->mtemplit;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mtemplit",  1);
    d_monst->mtemplit = bitfield;

    sfi_ulong(nhfp, &d_monst->mstrategy, parent, "mstrategy", 1);
    sfi_long(nhfp, &d_monst->mtrapseen, parent, "mtrapseen", 1);
    sfi_long(nhfp, &d_monst->mlstmv, parent, "mlstmv", 1);
    sfi_long(nhfp, &d_monst->mstate, parent, "mstate", 1);
    sfi_long(nhfp, &d_monst->migflags, parent, "migflags", 1);
    sfi_long(nhfp, &d_monst->mspare1, parent, "mspare1", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_monst->minvent, parent, "minvent", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_monst->mw, parent, "mw", 1);
    sfi_long(nhfp, &d_monst->misc_worn_check, parent, "misc_worn_check", 1);
    sfi_xchar(nhfp, &d_monst->weapon_check, parent, "weapon_check", 1);
    sfi_int(nhfp, &d_monst->meating, parent, "meating", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_monst->mextra, parent, "mextra", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "monst", 1);
}

void
sfi_mvitals(nhfp, d_mvitals, myparent, myname, cnt)
NHFILE *nhfp;
struct mvitals *d_mvitals;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "mvitals";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "mvitals", 1);

    sfi_uchar(nhfp, &d_mvitals->born, parent, "born", 1);
    sfi_uchar(nhfp, &d_mvitals->died, parent, "died", 1);
    sfi_uchar(nhfp, &d_mvitals->mvflags, parent, "mvflags", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "mvitals", 1);
}

void
sfi_nhcoord(nhfp, d_nhcoord, myparent, myname, cnt)
NHFILE *nhfp;
struct nhcoord *d_nhcoord;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "nhcoord";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "nhcoord", 1);

    sfi_xchar(nhfp, &d_nhcoord->x, parent, "x", 1);
    sfi_xchar(nhfp, &d_nhcoord->y, parent, "y", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "nhcoord", 1);
}

void
sfi_nhrect(nhfp, d_nhrect, myparent, myname, cnt)
NHFILE *nhfp;
struct nhrect *d_nhrect;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "nhrect";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "nhrect", 1);

    sfi_xchar(nhfp, &d_nhrect->lx, parent, "lx", 1);
    sfi_xchar(nhfp, &d_nhrect->ly, parent, "ly", 1);
    sfi_xchar(nhfp, &d_nhrect->hx, parent, "hx", 1);
    sfi_xchar(nhfp, &d_nhrect->hy, parent, "hy", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "nhrect", 1);
}

void
sfi_novel_tracking(nhfp, d_novel_tracking, myparent, myname, cnt)
NHFILE *nhfp;
struct novel_tracking *d_novel_tracking;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "novel_tracking";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "novel_tracking", 1);

    sfi_unsigned(nhfp, &d_novel_tracking->id, parent, "id", 1);
    sfi_int(nhfp, &d_novel_tracking->count, parent, "count", 1);
    sfi_xchar(nhfp, d_novel_tracking->pasg, parent, "pasg", 30);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "novel_tracking", 1);
}

void
sfi_obj(nhfp, d_obj, myparent, myname, cnt)
NHFILE *nhfp;
struct obj *d_obj;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "obj";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "obj", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_obj->nobj, parent, "nobj", 1);
    sfi_vptrs(nhfp, &d_obj->v, parent, "v", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_obj->cobj, parent, "cobj", 1);
    sfi_unsigned(nhfp, &d_obj->o_id, parent, "o_id", 1);
    sfi_xchar(nhfp, &d_obj->ox, parent, "ox", 1);
    sfi_xchar(nhfp, &d_obj->oy, parent, "oy", 1);
    sfi_short(nhfp, &d_obj->otyp, parent, "otyp", 1);
    sfi_unsigned(nhfp, &d_obj->owt, parent, "owt", 1);
    sfi_long(nhfp, &d_obj->quan, parent, "quan", 1);
    sfi_schar(nhfp, &d_obj->spe, parent, "spe", 1);
    sfi_char(nhfp, &d_obj->oclass, parent, "oclass", 1);
    sfi_char(nhfp, &d_obj->invlet, parent, "invlet", 1);
    sfi_char(nhfp, &d_obj->oartifact, parent, "oartifact", 1);
    sfi_xchar(nhfp, &d_obj->where, parent, "where", 1);
    sfi_xchar(nhfp, &d_obj->timed, parent, "timed", 1);
    bitfield = d_obj->cursed;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "cursed",  1);
    d_obj->cursed = bitfield;

    bitfield = d_obj->blessed;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "blessed",  1);
    d_obj->blessed = bitfield;

    bitfield = d_obj->unpaid;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "unpaid",  1);
    d_obj->unpaid = bitfield;

    bitfield = d_obj->no_charge;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "no_charge",  1);
    d_obj->no_charge = bitfield;

    bitfield = d_obj->known;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "known",  1);
    d_obj->known = bitfield;

    bitfield = d_obj->dknown;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "dknown",  1);
    d_obj->dknown = bitfield;

    bitfield = d_obj->bknown;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "bknown",  1);
    d_obj->bknown = bitfield;

    bitfield = d_obj->rknown;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "rknown",  1);
    d_obj->rknown = bitfield;

    bitfield = d_obj->oeroded;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oeroded",  2);
    d_obj->oeroded = bitfield;

    bitfield = d_obj->oeroded2;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oeroded2",  2);
    d_obj->oeroded2 = bitfield;

    bitfield = d_obj->oerodeproof;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oerodeproof",  1);
    d_obj->oerodeproof = bitfield;

    bitfield = d_obj->olocked;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "olocked",  1);
    d_obj->olocked = bitfield;

    bitfield = d_obj->obroken;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "obroken",  1);
    d_obj->obroken = bitfield;

    bitfield = d_obj->otrapped;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "otrapped",  1);
    d_obj->otrapped = bitfield;

    bitfield = d_obj->recharged;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "recharged",  3);
    d_obj->recharged = bitfield;

    bitfield = d_obj->lamplit;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "lamplit",  1);
    d_obj->lamplit = bitfield;

    bitfield = d_obj->globby;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "globby",  1);
    d_obj->globby = bitfield;

    bitfield = d_obj->greased;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "greased",  1);
    d_obj->greased = bitfield;

    bitfield = d_obj->nomerge;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "nomerge",  1);
    d_obj->nomerge = bitfield;

    bitfield = d_obj->was_thrown;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "was_thrown",  1);
    d_obj->was_thrown = bitfield;

    bitfield = d_obj->in_use;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "in_use",  1);
    d_obj->in_use = bitfield;

    bitfield = d_obj->bypass;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "bypass",  1);
    d_obj->bypass = bitfield;

    bitfield = d_obj->cknown;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "cknown",  1);
    d_obj->cknown = bitfield;

    bitfield = d_obj->lknown;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "lknown",  1);
    d_obj->lknown = bitfield;

    sfi_int(nhfp, &d_obj->corpsenm, parent, "corpsenm", 1);
    sfi_int(nhfp, &d_obj->usecount, parent, "usecount", 1);
    sfi_unsigned(nhfp, &d_obj->oeaten, parent, "oeaten", 1);
    sfi_long(nhfp, &d_obj->age, parent, "age", 1);
    sfi_long(nhfp, &d_obj->owornmask, parent, "owornmask", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_obj->oextra, parent, "oextra", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "obj", 1);
}

void
sfi_objclass(nhfp, d_objclass, myparent, myname, cnt)
NHFILE *nhfp;
struct objclass *d_objclass;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "objclass";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "objclass", 1);

    sfi_short(nhfp, &d_objclass->oc_name_idx, parent, "oc_name_idx", 1);
    sfi_short(nhfp, &d_objclass->oc_descr_idx, parent, "oc_descr_idx", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_objclass->oc_uname, parent, "oc_uname", 1);
    bitfield = d_objclass->oc_name_known;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_name_known",  1);
    d_objclass->oc_name_known = bitfield;

    bitfield = d_objclass->oc_merge;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_merge",  1);
    d_objclass->oc_merge = bitfield;

    bitfield = d_objclass->oc_uses_known;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_uses_known",  1);
    d_objclass->oc_uses_known = bitfield;

    bitfield = d_objclass->oc_pre_discovered;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_pre_discovered",  1);
    d_objclass->oc_pre_discovered = bitfield;

    bitfield = d_objclass->oc_magic;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_magic",  1);
    d_objclass->oc_magic = bitfield;

    bitfield = d_objclass->oc_charged;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_charged",  1);
    d_objclass->oc_charged = bitfield;

    bitfield = d_objclass->oc_unique;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_unique",  1);
    d_objclass->oc_unique = bitfield;

    bitfield = d_objclass->oc_nowish;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_nowish",  1);
    d_objclass->oc_nowish = bitfield;

    bitfield = d_objclass->oc_big;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_big",  1);
    d_objclass->oc_big = bitfield;

    bitfield = d_objclass->oc_tough;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_tough",  1);
    d_objclass->oc_tough = bitfield;

    bitfield = d_objclass->oc_dir;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_dir",  2);
    d_objclass->oc_dir = bitfield;

    bitfield = d_objclass->oc_material;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "oc_material",  5);
    d_objclass->oc_material = bitfield;

    sfi_schar(nhfp, &d_objclass->oc_subtyp, parent, "oc_subtyp", 1);
    sfi_uchar(nhfp, &d_objclass->oc_oprop, parent, "oc_oprop", 1);
    sfi_char(nhfp, &d_objclass->oc_class, parent, "oc_class", 1);
    sfi_schar(nhfp, &d_objclass->oc_delay, parent, "oc_delay", 1);
    sfi_uchar(nhfp, &d_objclass->oc_color, parent, "oc_color", 1);
    sfi_short(nhfp, &d_objclass->oc_prob, parent, "oc_prob", 1);
    sfi_ushort(nhfp, &d_objclass->oc_weight, parent, "oc_weight", 1);
    sfi_short(nhfp, &d_objclass->oc_cost, parent, "oc_cost", 1);
    sfi_schar(nhfp, &d_objclass->oc_wsdam, parent, "oc_wsdam", 1);
    sfi_schar(nhfp, &d_objclass->oc_wldam, parent, "oc_wldam", 1);
    sfi_schar(nhfp, &d_objclass->oc_oc1, parent, "oc_oc1", 1);
    sfi_schar(nhfp, &d_objclass->oc_oc2, parent, "oc_oc2", 1);
    sfi_ushort(nhfp, &d_objclass->oc_nutrition, parent, "oc_nutrition", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "objclass", 1);
}

void
sfi_obj_split(nhfp, d_obj_split, myparent, myname, cnt)
NHFILE *nhfp;
struct obj_split *d_obj_split;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "obj_split";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "obj_split", 1);

    sfi_unsigned(nhfp, &d_obj_split->parent_oid, parent, "parent_oid", 1);
    sfi_unsigned(nhfp, &d_obj_split->child_oid, parent, "child_oid", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "obj_split", 1);
}

void
sfi_oextra(nhfp, d_oextra, myparent, myname, cnt)
NHFILE *nhfp;
struct oextra *d_oextra;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "oextra";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "oextra", 1);

    sfi_char(nhfp, d_oextra->oname, parent, "oname", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_oextra->omonst, parent, "omonst", 1);
    sfi_unsigned(nhfp, d_oextra->omid, parent, "omid", 1);
    sfi_long(nhfp, d_oextra->olong, parent, "olong", 1);
    sfi_char(nhfp, d_oextra->omailcmd, parent, "omailcmd", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "oextra", 1);
}

void
sfi_polearm_info(nhfp, d_polearm_info, myparent, myname, cnt)
NHFILE *nhfp;
struct polearm_info *d_polearm_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "polearm_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "polearm_info", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_polearm_info->hitmon, parent, "hitmon", 1);
    sfi_unsigned(nhfp, &d_polearm_info->m_id, parent, "m_id", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "polearm_info", 1);
}

void
sfi_prop(nhfp, d_prop, myparent, myname, cnt)
NHFILE *nhfp;
struct prop *d_prop;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "prop";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "prop", 1);

    sfi_long(nhfp, &d_prop->extrinsic, parent, "extrinsic", 1);
    sfi_long(nhfp, &d_prop->blocked, parent, "blocked", 1);
    sfi_long(nhfp, &d_prop->intrinsic, parent, "intrinsic", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "prop", 1);
}

void
sfi_q_score(nhfp, d_q_score, myparent, myname, cnt)
NHFILE *nhfp;
struct q_score *d_q_score;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "q_score";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "q_score", 1);

    bitfield = d_q_score->first_start;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "first_start",  1);
    d_q_score->first_start = bitfield;

    bitfield = d_q_score->met_leader;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "met_leader",  1);
    d_q_score->met_leader = bitfield;

    bitfield = d_q_score->not_ready;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "not_ready",  3);
    d_q_score->not_ready = bitfield;

    bitfield = d_q_score->pissed_off;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "pissed_off",  1);
    d_q_score->pissed_off = bitfield;

    bitfield = d_q_score->got_quest;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "got_quest",  1);
    d_q_score->got_quest = bitfield;

    bitfield = d_q_score->first_locate;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "first_locate",  1);
    d_q_score->first_locate = bitfield;

    bitfield = d_q_score->met_intermed;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "met_intermed",  1);
    d_q_score->met_intermed = bitfield;

    bitfield = d_q_score->got_final;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "got_final",  1);
    d_q_score->got_final = bitfield;

    bitfield = d_q_score->made_goal;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "made_goal",  3);
    d_q_score->made_goal = bitfield;

    bitfield = d_q_score->met_nemesis;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "met_nemesis",  1);
    d_q_score->met_nemesis = bitfield;

    bitfield = d_q_score->killed_nemesis;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "killed_nemesis",  1);
    d_q_score->killed_nemesis = bitfield;

    bitfield = d_q_score->in_battle;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "in_battle",  1);
    d_q_score->in_battle = bitfield;

    bitfield = d_q_score->cheater;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "cheater",  1);
    d_q_score->cheater = bitfield;

    bitfield = d_q_score->touched_artifact;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "touched_artifact",  1);
    d_q_score->touched_artifact = bitfield;

    bitfield = d_q_score->offered_artifact;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "offered_artifact",  1);
    d_q_score->offered_artifact = bitfield;

    bitfield = d_q_score->got_thanks;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "got_thanks",  1);
    d_q_score->got_thanks = bitfield;

    bitfield = d_q_score->ldrgend;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ldrgend",  2);
    d_q_score->ldrgend = bitfield;

    bitfield = d_q_score->nemgend;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "nemgend",  2);
    d_q_score->nemgend = bitfield;

    bitfield = d_q_score->godgend;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "godgend",  2);
    d_q_score->godgend = bitfield;

    bitfield = d_q_score->leader_is_dead;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "leader_is_dead",  1);
    d_q_score->leader_is_dead = bitfield;

    sfi_unsigned(nhfp, &d_q_score->leader_m_id, parent, "leader_m_id", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "q_score", 1);
}

void
sfi_rm(nhfp, d_rm, myparent, myname, cnt)
NHFILE *nhfp;
struct rm *d_rm;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "rm";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "rm", 1);

    sfi_int(nhfp, &d_rm->glyph, parent, "glyph", 1);
    sfi_schar(nhfp, &d_rm->typ, parent, "typ", 1);
    sfi_uchar(nhfp, &d_rm->seenv, parent, "seenv", 1);
    bitfield = d_rm->flags;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "flags",  5);
    d_rm->flags = bitfield;

    bitfield = d_rm->horizontal;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "horizontal",  1);
    d_rm->horizontal = bitfield;

    bitfield = d_rm->lit;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "lit",  1);
    d_rm->lit = bitfield;

    bitfield = d_rm->waslit;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "waslit",  1);
    d_rm->waslit = bitfield;

    bitfield = d_rm->roomno;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "roomno",  6);
    d_rm->roomno = bitfield;

    bitfield = d_rm->edge;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "edge",  1);
    d_rm->edge = bitfield;

    bitfield = d_rm->candig;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "candig",  1);
    d_rm->candig = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "rm", 1);
}

void
sfi_s_level(nhfp, d_s_level, myparent, myname, cnt)
NHFILE *nhfp;
struct s_level *d_s_level;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "s_level";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "s_level", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_s_level->next, parent, "next", 1);
    sfi_d_level(nhfp, &d_s_level->dlevel, parent, "dlevel", 1);
    sfi_char(nhfp, d_s_level->proto, parent, "proto", 15);
    sfi_char(nhfp, &d_s_level->boneid, parent, "boneid", 1);
    sfi_uchar(nhfp, &d_s_level->rndlevs, parent, "rndlevs", 1);
    sfi_d_flags(nhfp, &d_s_level->flags, parent, "flags", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "s_level", 1);
}

void
sfi_savefile_info(nhfp, d_savefile_info, myparent, myname, cnt)
NHFILE *nhfp;
struct savefile_info *d_savefile_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "savefile_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "savefile_info", 1);

    sfi_ulong(nhfp, &d_savefile_info->sfi1, parent, "sfi1", 1);
    sfi_ulong(nhfp, &d_savefile_info->sfi2, parent, "sfi2", 1);
    sfi_ulong(nhfp, &d_savefile_info->sfi3, parent, "sfi3", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "savefile_info", 1);
}

void
sfi_skills(nhfp, d_skills, myparent, myname, cnt)
NHFILE *nhfp;
struct skills *d_skills;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "skills";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "skills", 1);

    sfi_xchar(nhfp, &d_skills->skill, parent, "skill", 1);
    sfi_xchar(nhfp, &d_skills->max_skill, parent, "max_skill", 1);
    sfi_ushort(nhfp, &d_skills->advance, parent, "advance", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "skills", 1);
}

void
sfi_spell(nhfp, d_spell, myparent, myname, cnt)
NHFILE *nhfp;
struct spell *d_spell;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "spell";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "spell", 1);

    sfi_short(nhfp, &d_spell->sp_id, parent, "sp_id", 1);
    sfi_xchar(nhfp, &d_spell->sp_lev, parent, "sp_lev", 1);
    sfi_int(nhfp, &d_spell->sp_know, parent, "sp_know", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "spell", 1);
}

void
sfi_stairway(nhfp, d_stairway, myparent, myname, cnt)
NHFILE *nhfp;
struct stairway *d_stairway;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "stairway";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "stairway", 1);

    sfi_xchar(nhfp, &d_stairway->sx, parent, "sx", 1);
    sfi_xchar(nhfp, &d_stairway->sy, parent, "sy", 1);
    sfi_d_level(nhfp, &d_stairway->tolev, parent, "tolev", 1);
    sfi_char(nhfp, &d_stairway->up, parent, "up", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "stairway", 1);
}

void
sfi_takeoff_info(nhfp, d_takeoff_info, myparent, myname, cnt)
NHFILE *nhfp;
struct takeoff_info *d_takeoff_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "takeoff_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "takeoff_info", 1);

    sfi_long(nhfp, &d_takeoff_info->mask, parent, "mask", 1);
    sfi_long(nhfp, &d_takeoff_info->what, parent, "what", 1);
    sfi_int(nhfp, &d_takeoff_info->delay, parent, "delay", 1);
    sfi_boolean(nhfp, &d_takeoff_info->cancelled_don, parent, "cancelled_don", 1);
    sfi_char(nhfp, d_takeoff_info->disrobing, parent, "disrobing", CONTEXTVERBSZ + 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "takeoff_info", 1);
}

void
sfi_tin_info(nhfp, d_tin_info, myparent, myname, cnt)
NHFILE *nhfp;
struct tin_info *d_tin_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "tin_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "tin_info", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_tin_info->tin, parent, "tin", 1);
    sfi_unsigned(nhfp, &d_tin_info->o_id, parent, "o_id", 1);
    sfi_int(nhfp, &d_tin_info->usedtime, parent, "usedtime", 1);
    sfi_int(nhfp, &d_tin_info->reqtime, parent, "reqtime", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "tin_info", 1);
}

void
sfi_trap(nhfp, d_trap, myparent, myname, cnt)
NHFILE *nhfp;
struct trap *d_trap;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "trap";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "trap", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_trap->ntrap, parent, "ntrap", 1);
    sfi_xchar(nhfp, &d_trap->tx, parent, "tx", 1);
    sfi_xchar(nhfp, &d_trap->ty, parent, "ty", 1);
    sfi_d_level(nhfp, &d_trap->dst, parent, "dst", 1);
    sfi_nhcoord(nhfp, &d_trap->launch, parent, "launch", 1);
    bitfield = d_trap->ttyp;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ttyp",  5);
    d_trap->ttyp = bitfield;

    bitfield = d_trap->tseen;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "tseen",  1);
    d_trap->tseen = bitfield;

    bitfield = d_trap->once;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "once",  1);
    d_trap->once = bitfield;

    bitfield = d_trap->madeby_u;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "madeby_u",  1);
    d_trap->madeby_u = bitfield;

    sfi_vlaunchinfo(nhfp, &d_trap->vl, parent, "vl", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "trap", 1);
}

void
sfi_tribute_info(nhfp, d_tribute_info, myparent, myname, cnt)
NHFILE *nhfp;
struct tribute_info *d_tribute_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "tribute_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "tribute_info", 1);

    sfi_size_t(nhfp, &d_tribute_info->tributesz, parent, "tributesz", 1);
    sfi_boolean(nhfp, &d_tribute_info->enabled, parent, "enabled", 1);
    bitfield = d_tribute_info->bookstock;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "bookstock",  1);
    d_tribute_info->bookstock = bitfield;

    bitfield = d_tribute_info->Deathnotice;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "Deathnotice", 1);
    d_tribute_info->Deathnotice = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "tribute_info", 1);
}

void
sfi_u_achieve(nhfp, d_u_achieve, myparent, myname, cnt)
NHFILE *nhfp;
struct u_achieve *d_u_achieve;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_achieve";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "u_achieve", 1);

    bitfield = d_u_achieve->amulet;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "amulet",  1);
    d_u_achieve->amulet = bitfield;

    bitfield = d_u_achieve->bell;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "bell",  1);
    d_u_achieve->bell = bitfield;

    bitfield = d_u_achieve->book;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "book",  1);
    d_u_achieve->book = bitfield;

    bitfield = d_u_achieve->menorah;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "menorah",  1);
    d_u_achieve->menorah = bitfield;

    bitfield = d_u_achieve->enter_gehennom;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "enter_gehennom", 1);
    d_u_achieve->enter_gehennom = bitfield;

    bitfield = d_u_achieve->ascended;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ascended",  1);
    d_u_achieve->ascended = bitfield;

    bitfield = d_u_achieve->mines_luckstone;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mines_luckstone",  1);
    d_u_achieve->mines_luckstone = bitfield;

    bitfield = d_u_achieve->finish_sokoban;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "finish_sokoban",  1);
    d_u_achieve->finish_sokoban = bitfield;

    bitfield = d_u_achieve->killed_medusa;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "killed_medusa",  1);
    d_u_achieve->killed_medusa = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "u_achieve", 1);
}

void
sfi_u_conduct(nhfp, d_u_conduct, myparent, myname, cnt)
NHFILE *nhfp;
struct u_conduct *d_u_conduct;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_conduct";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "u_conduct", 1);

    sfi_long(nhfp, &d_u_conduct->unvegetarian, parent, "unvegetarian", 1);
    sfi_long(nhfp, &d_u_conduct->unvegan, parent, "unvegan", 1);
    sfi_long(nhfp, &d_u_conduct->food, parent, "food", 1);
    sfi_long(nhfp, &d_u_conduct->gnostic, parent, "gnostic", 1);
    sfi_long(nhfp, &d_u_conduct->weaphit, parent, "weaphit", 1);
    sfi_long(nhfp, &d_u_conduct->killer, parent, "killer", 1);
    sfi_long(nhfp, &d_u_conduct->literate, parent, "literate", 1);
    sfi_long(nhfp, &d_u_conduct->polypiles, parent, "polypiles", 1);
    sfi_long(nhfp, &d_u_conduct->polyselfs, parent, "polyselfs", 1);
    sfi_long(nhfp, &d_u_conduct->wishes, parent, "wishes", 1);
    sfi_long(nhfp, &d_u_conduct->wisharti, parent, "wisharti", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "u_conduct", 1);
}

void
sfi_u_event(nhfp, d_u_event, myparent, myname, cnt)
NHFILE *nhfp;
struct u_event *d_u_event;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_event";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "u_event", 1);

    bitfield = d_u_event->minor_oracle;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "minor_oracle",  1);
    d_u_event->minor_oracle = bitfield;

    bitfield = d_u_event->major_oracle;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "major_oracle",  1);
    d_u_event->major_oracle = bitfield;

    bitfield = d_u_event->read_tribute;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "read_tribute",  1);
    d_u_event->read_tribute = bitfield;

    bitfield = d_u_event->qcalled;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "qcalled",  1);
    d_u_event->qcalled = bitfield;

    bitfield = d_u_event->qexpelled;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "qexpelled",  1);
    d_u_event->qexpelled = bitfield;

    bitfield = d_u_event->qcompleted;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "qcompleted",  1);
    d_u_event->qcompleted = bitfield;

    bitfield = d_u_event->uheard_tune;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uheard_tune",  2);
    d_u_event->uheard_tune = bitfield;

    bitfield = d_u_event->uopened_dbridge;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uopened_dbridge",  1);
    d_u_event->uopened_dbridge = bitfield;

    bitfield = d_u_event->invoked;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "invoked",  1);
    d_u_event->invoked = bitfield;

    bitfield = d_u_event->gehennom_entered;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "gehennom_entered",  1);
    d_u_event->gehennom_entered = bitfield;

    bitfield = d_u_event->uhand_of_elbereth;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uhand_of_elbereth",  2);
    d_u_event->uhand_of_elbereth = bitfield;

    bitfield = d_u_event->udemigod;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "udemigod",  1);
    d_u_event->udemigod = bitfield;

    bitfield = d_u_event->uvibrated;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uvibrated",  1);
    d_u_event->uvibrated = bitfield;

    bitfield = d_u_event->ascended;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "ascended",  1);
    d_u_event->ascended = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "u_event", 1);
}

void
sfi_u_have(nhfp, d_u_have, myparent, myname, cnt)
NHFILE *nhfp;
struct u_have *d_u_have;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_have";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "u_have", 1);

    bitfield = d_u_have->amulet;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "amulet",  1);
    d_u_have->amulet = bitfield;

    bitfield = d_u_have->bell;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "bell",  1);
    d_u_have->bell = bitfield;

    bitfield = d_u_have->book;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "book",  1);
    d_u_have->book = bitfield;

    bitfield = d_u_have->menorah;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "menorah",  1);
    d_u_have->menorah = bitfield;

    bitfield = d_u_have->questart;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "questart",  1);
    d_u_have->questart = bitfield;

    bitfield = d_u_have->unused;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "unused",  3);
    d_u_have->unused = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "u_have", 1);
}

void
sfi_u_realtime(nhfp, d_u_realtime, myparent, myname, cnt)
NHFILE *nhfp;
struct u_realtime *d_u_realtime;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_realtime";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "u_realtime", 1);

    sfi_long(nhfp, &d_u_realtime->realtime, parent, "realtime", 1);
    sfi_time_t(nhfp, &d_u_realtime->start_timing, parent, "start_timing", 1);
    sfi_time_t(nhfp, &d_u_realtime->finish_time, parent, "finish_time", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "u_realtime", 1);
}

void
sfi_u_roleplay(nhfp, d_u_roleplay, myparent, myname, cnt)
NHFILE *nhfp;
struct u_roleplay *d_u_roleplay;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "u_roleplay";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "u_roleplay", 1);

    sfi_boolean(nhfp, &d_u_roleplay->blind, parent, "blind", 1);
    sfi_boolean(nhfp, &d_u_roleplay->nudist, parent, "nudist", 1);
    sfi_long(nhfp, &d_u_roleplay->numbones, parent, "numbones", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "u_roleplay", 1);
}

void
sfi_version_info(nhfp, d_version_info, myparent, myname, cnt)
NHFILE *nhfp;
struct version_info *d_version_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "version_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "version_info", 1);

    sfi_ulong(nhfp, &d_version_info->incarnation, parent, "incarnation", 1);
    sfi_ulong(nhfp, &d_version_info->feature_set, parent, "feature_set", 1);
    sfi_ulong(nhfp, &d_version_info->entity_count, parent, "entity_count", 1);
    sfi_ulong(nhfp, &d_version_info->struct_sizes1, parent, "struct_sizes1", 1);
    sfi_ulong(nhfp, &d_version_info->struct_sizes2, parent, "struct_sizes2", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "version_info", 1);
}

void
sfi_victual_info(nhfp, d_victual_info, myparent, myname, cnt)
NHFILE *nhfp;
struct victual_info *d_victual_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "victual_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "victual_info", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_victual_info->piece, parent, "piece", 1);
    sfi_unsigned(nhfp, &d_victual_info->o_id, parent, "o_id", 1);
    sfi_int(nhfp, &d_victual_info->usedtime, parent, "usedtime", 1);
    sfi_int(nhfp, &d_victual_info->reqtime, parent, "reqtime", 1);
    sfi_int(nhfp, &d_victual_info->nmod, parent, "nmod", 1);
    bitfield = d_victual_info->canchoke;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "canchoke",  1);
    d_victual_info->canchoke = bitfield;

    bitfield = d_victual_info->fullwarn;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "fullwarn",  1);
    d_victual_info->fullwarn = bitfield;

    bitfield = d_victual_info->eating;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "eating",  1);
    d_victual_info->eating = bitfield;

    bitfield = d_victual_info->doreset;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "doreset",  1);
    d_victual_info->doreset = bitfield;


    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "victual_info", 1);
}

void
sfi_vlaunchinfo(nhfp, d_vlaunchinfo, myparent, myname, cnt)
NHFILE *nhfp;
union vlaunchinfo *d_vlaunchinfo;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "vlaunchinfo";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "vlaunchinfo", 1);

    sfi_short(nhfp, &d_vlaunchinfo->v_launch_otyp, parent, "v_launch_otyp", 1);
    sfi_nhcoord(nhfp, &d_vlaunchinfo->v_launch2, parent, "v_launch2", 1);
    sfi_uchar(nhfp, &d_vlaunchinfo->v_conjoined, parent, "v_conjoined", 1);
    sfi_short(nhfp, &d_vlaunchinfo->v_tnote, parent, "v_tnote", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "vlaunchinfo", 1);
}

void
sfi_vptrs(nhfp, d_vptrs, myparent, myname, cnt)
NHFILE *nhfp;
union vptrs *d_vptrs;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "vptrs";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "vptrs", 1);

    sfi_genericptr(nhfp, (genericptr_t) &d_vptrs->v_nexthere, parent, "v_nexthere", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_vptrs->v_ocontainer, parent, "v_ocontainer", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_vptrs->v_ocarry, parent, "v_ocarry", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "vptrs", 1);
}

void
sfi_warntype_info(nhfp, d_warntype_info, myparent, myname, cnt)
NHFILE *nhfp;
struct warntype_info *d_warntype_info;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "warntype_info";

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "warntype_info", 1);

    sfi_ulong(nhfp, &d_warntype_info->obj, parent, "obj", 1);
    sfi_ulong(nhfp, &d_warntype_info->polyd, parent, "polyd", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_warntype_info->species, parent, "species", 1);
    sfi_short(nhfp, &d_warntype_info->speciesidx, parent, "speciesidx", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "warntype_info", 1);
}

void
sfi_you(nhfp, d_you, myparent, myname, cnt)
NHFILE *nhfp;
struct you *d_you;
const char *myparent;
const char *myname;
int cnt;
{
    const char *parent = "you";
    int i;

    nhUse(myname);
    nhUse(cnt);
    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "start", "you", 1);

    sfi_xchar(nhfp, &d_you->ux, parent, "ux", 1);
    sfi_xchar(nhfp, &d_you->uy, parent, "uy", 1);
    sfi_schar(nhfp, &d_you->dx, parent, "dx", 1);
    sfi_schar(nhfp, &d_you->dy, parent, "dy", 1);
    sfi_schar(nhfp, &d_you->dz, parent, "dz", 1);
    sfi_schar(nhfp, &d_you->di, parent, "di", 1);
    sfi_xchar(nhfp, &d_you->tx, parent, "tx", 1);
    sfi_xchar(nhfp, &d_you->ty, parent, "ty", 1);
    sfi_xchar(nhfp, &d_you->ux0, parent, "ux0", 1);
    sfi_xchar(nhfp, &d_you->uy0, parent, "uy0", 1);
    sfi_d_level(nhfp, &d_you->uz, parent, "uz", 1);
    sfi_d_level(nhfp, &d_you->uz0, parent, "uz0", 1);
    sfi_d_level(nhfp, &d_you->utolev, parent, "utolev", 1);
    sfi_uchar(nhfp, &d_you->utotype, parent, "utotype", 1);
    sfi_boolean(nhfp, &d_you->umoved, parent, "umoved", 1);
    sfi_int(nhfp, &d_you->last_str_turn, parent, "last_str_turn", 1);
    sfi_int(nhfp, &d_you->ulevel, parent, "ulevel", 1);
    sfi_int(nhfp, &d_you->ulevelmax, parent, "ulevelmax", 1);
    sfi_unsigned(nhfp, &d_you->utrap, parent, "utrap", 1);
    sfi_unsigned(nhfp, &d_you->utraptype, parent, "utraptype", 1);
    sfi_char(nhfp, d_you->urooms, parent, "urooms", 5);
    sfi_char(nhfp, d_you->urooms0, parent, "urooms0", 5);
    sfi_char(nhfp, d_you->uentered, parent, "uentered", 5);
    sfi_char(nhfp, d_you->ushops, parent, "ushops", 5);
    sfi_char(nhfp, d_you->ushops0, parent, "ushops0", 5);
    sfi_char(nhfp, d_you->ushops_entered, parent, "ushops_entered", 5);
    sfi_char(nhfp, d_you->ushops_left, parent, "ushops_left", 5);
    sfi_int(nhfp, &d_you->uhunger, parent, "uhunger", 1);
    sfi_unsigned(nhfp, &d_you->uhs, parent, "uhs", 1);
    sfi_prop(nhfp, d_you->uprops, parent, "uprops", LAST_PROP + 1);
    sfi_unsigned(nhfp, &d_you->umconf, parent, "umconf", 1);
    bitfield = d_you->usick_type;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "usick_type",  2);
    d_you->usick_type = bitfield;

    sfi_int(nhfp, &d_you->nv_range, parent, "nv_range", 1);
    sfi_int(nhfp, &d_you->xray_range, parent, "xray_range", 1);
    sfi_int(nhfp, &d_you->bglyph, parent, "bglyph", 1);
    sfi_int(nhfp, &d_you->cglyph, parent, "cglyph", 1);
    sfi_int(nhfp, &d_you->bc_order, parent, "bc_order", 1);
    sfi_int(nhfp, &d_you->bc_felt, parent, "bc_felt", 1);
    sfi_int(nhfp, &d_you->umonster, parent, "umonster", 1);
    sfi_int(nhfp, &d_you->umonnum, parent, "umonnum", 1);
    sfi_int(nhfp, &d_you->mh, parent, "mh", 1);
    sfi_int(nhfp, &d_you->mhmax, parent, "mhmax", 1);
    sfi_int(nhfp, &d_you->mtimedone, parent, "mtimedone", 1);
    sfi_attribs(nhfp, &d_you->macurr, parent, "macurr", 1);
    sfi_attribs(nhfp, &d_you->mamax, parent, "mamax", 1);
    sfi_int(nhfp, &d_you->ulycn, parent, "ulycn", 1);
    sfi_unsigned(nhfp, &d_you->ucreamed, parent, "ucreamed", 1);
    sfi_unsigned(nhfp, &d_you->uswldtim, parent, "uswldtim", 1);
    bitfield = d_you->uswallow;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uswallow",  1);
    d_you->uswallow = bitfield;

    bitfield = d_you->uinwater;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uinwater",  1);
    d_you->uinwater = bitfield;

    bitfield = d_you->uundetected;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uundetected",  1);
    d_you->uundetected = bitfield;

    bitfield = d_you->mfemale;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "mfemale",  1);
    d_you->mfemale = bitfield;

    bitfield = d_you->uinvulnerable;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uinvulnerable",  1);
    d_you->uinvulnerable = bitfield;

    bitfield = d_you->uburied;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uburied",  1);
    d_you->uburied = bitfield;

    bitfield = d_you->uedibility;       /* set it to current value for testing */
    sfi_bitfield(nhfp, &bitfield, parent, "uedibility",  1);
    d_you->uedibility = bitfield;

    sfi_unsigned(nhfp, &d_you->udg_cnt, parent, "udg_cnt", 1);
    sfi_u_achieve(nhfp, &d_you->uachieve, parent, "uachieve", 1);
    sfi_u_event(nhfp, &d_you->uevent, parent, "uevent", 1);
    sfi_u_have(nhfp, &d_you->uhave, parent, "uhave", 1);
    sfi_u_conduct(nhfp, &d_you->uconduct, parent, "uconduct", 1);
    sfi_u_roleplay(nhfp, &d_you->uroleplay, parent, "uroleplay", 1);
    sfi_attribs(nhfp, &d_you->acurr, parent, "acurr", 1);
    sfi_attribs(nhfp, &d_you->aexe, parent, "aexe", 1);
    sfi_attribs(nhfp, &d_you->abon, parent, "abon", 1);
    sfi_attribs(nhfp, &d_you->amax, parent, "amax", 1);
    sfi_attribs(nhfp, &d_you->atemp, parent, "atemp", 1);
    sfi_attribs(nhfp, &d_you->atime, parent, "atime", 1);
    sfi_align(nhfp, &d_you->ualign, parent, "ualign", 1);
    for (i = 0; i < CONVERT; ++i)
        sfi_aligntyp(nhfp, &d_you->ualignbase[i], parent, "ualignbase", 1);
    sfi_schar(nhfp, &d_you->uluck, parent, "uluck", 1);
    sfi_schar(nhfp, &d_you->moreluck, parent, "moreluck", 1);
    sfi_schar(nhfp, &d_you->uhitinc, parent, "uhitinc", 1);
    sfi_schar(nhfp, &d_you->udaminc, parent, "udaminc", 1);
    sfi_schar(nhfp, &d_you->uac, parent, "uac", 1);
    sfi_uchar(nhfp, &d_you->uspellprot, parent, "uspellprot", 1);
    sfi_uchar(nhfp, &d_you->usptime, parent, "usptime", 1);
    sfi_uchar(nhfp, &d_you->uspmtime, parent, "uspmtime", 1);
    sfi_int(nhfp, &d_you->uhp, parent, "uhp", 1);
    sfi_int(nhfp, &d_you->uhpmax, parent, "uhpmax", 1);
    sfi_int(nhfp, &d_you->uen, parent, "uen", 1);
    sfi_int(nhfp, &d_you->uenmax, parent, "uenmax", 1);
    sfi_xchar(nhfp, d_you->uhpinc, parent, "uhpinc", MAXULEV);
    sfi_xchar(nhfp, d_you->ueninc, parent, "ueninc", MAXULEV);
    sfi_int(nhfp, &d_you->ugangr, parent, "ugangr", 1);
    sfi_int(nhfp, &d_you->ugifts, parent, "ugifts", 1);
    sfi_int(nhfp, &d_you->ublessed, parent, "ublessed", 1);
    sfi_int(nhfp, &d_you->ublesscnt, parent, "ublesscnt", 1);
    sfi_long(nhfp, &d_you->umoney0, parent, "umoney0", 1);
    sfi_long(nhfp, &d_you->uspare1, parent, "uspare1", 1);
    sfi_long(nhfp, &d_you->uexp, parent, "uexp", 1);
    sfi_long(nhfp, &d_you->urexp, parent, "urexp", 1);
    sfi_long(nhfp, &d_you->ucleansed, parent, "ucleansed", 1);
    sfi_long(nhfp, &d_you->usleep, parent, "usleep", 1);
    sfi_int(nhfp, &d_you->uinvault, parent, "uinvault", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_you->ustuck, parent, "ustuck", 1);
    sfi_genericptr(nhfp, (genericptr_t) &d_you->usteed, parent, "usteed", 1);
    sfi_long(nhfp, &d_you->ugallop, parent, "ugallop", 1);
    sfi_int(nhfp, &d_you->urideturns, parent, "urideturns", 1);
    sfi_int(nhfp, &d_you->umortality, parent, "umortality", 1);
    sfi_int(nhfp, &d_you->ugrave_arise, parent, "ugrave_arise", 1);
    sfi_int(nhfp, &d_you->weapon_slots, parent, "weapon_slots", 1);
    sfi_int(nhfp, &d_you->skills_advanced, parent, "skills_advanced", 1);
    sfi_xchar(nhfp, d_you->skill_record, parent, "skill_record", P_SKILL_LIMIT);
    for (i = 0; i < P_NUM_SKILLS; ++i)
        sfi_skills(nhfp, &d_you->weapon_skills[i], parent, "weapon_skills", 1);
    sfi_boolean(nhfp, &d_you->twoweap, parent, "twoweap", 1);
    sfi_short(nhfp, &d_you->mcham, parent, "mcham", 1);

    if (nhfp->addinfo)
        sfi_addinfo(nhfp, myparent, "end", "you", 1);
}
struct nhdatatypes_t nhdatatypes[] = {
	{NHTYPE_SIMPLE, (char *) "any", sizeof(anything)},
	{NHTYPE_SIMPLE, (char *) "genericptr_t", sizeof(genericptr_t)},
	{NHTYPE_SIMPLE, (char *) "aligntyp", sizeof(aligntyp)},
	{NHTYPE_SIMPLE, (char *) "Bitfield", sizeof(uint8_t)},
	{NHTYPE_SIMPLE, (char *) "boolean", sizeof(boolean)},
	{NHTYPE_SIMPLE, (char *) "char", sizeof(char)},
	{NHTYPE_SIMPLE, (char *) "int", sizeof(int)},
	{NHTYPE_SIMPLE, (char *) "long", sizeof(long)},
	{NHTYPE_SIMPLE, (char *) "schar", sizeof(schar)},
	{NHTYPE_SIMPLE, (char *) "short", sizeof(short)},
	{NHTYPE_SIMPLE, (char *) "size_t", sizeof(size_t)},
	{NHTYPE_SIMPLE, (char *) "string", sizeof(uchar)},
	{NHTYPE_SIMPLE, (char *) "time_t", sizeof(time_t)},
	{NHTYPE_SIMPLE, (char *) "uchar", sizeof(uchar)},
	{NHTYPE_SIMPLE, (char *) "unsigned char", sizeof(unsigned char)},
	{NHTYPE_SIMPLE, (char *) "unsigned int", sizeof(unsigned int)},
	{NHTYPE_SIMPLE, (char *) "unsigned long", sizeof(unsigned long)},
	{NHTYPE_SIMPLE, (char *) "unsigned short", sizeof(unsigned short)},
	{NHTYPE_SIMPLE, (char *) "unsigned", sizeof(unsigned)},
	{NHTYPE_SIMPLE, (char *) "xchar", sizeof(xchar)},
	{NHTYPE_COMPLEX, (char *) "align", sizeof(struct align)},
	{NHTYPE_COMPLEX, (char *) "attribs", sizeof(struct attribs)},
	{NHTYPE_COMPLEX, (char *) "dig_info", sizeof(struct dig_info)},
	{NHTYPE_COMPLEX, (char *) "tin_info", sizeof(struct tin_info)},
	{NHTYPE_COMPLEX, (char *) "book_info", sizeof(struct book_info)},
	{NHTYPE_COMPLEX, (char *) "takeoff_info", sizeof(struct takeoff_info)},
	{NHTYPE_COMPLEX, (char *) "victual_info", sizeof(struct victual_info)},
	{NHTYPE_COMPLEX, (char *) "warntype_info", sizeof(struct warntype_info)},
	{NHTYPE_COMPLEX, (char *) "polearm_info", sizeof(struct polearm_info)},
	{NHTYPE_COMPLEX, (char *) "obj_split", sizeof(struct obj_split)},
	{NHTYPE_COMPLEX, (char *) "tribute_info", sizeof(struct tribute_info)},
	{NHTYPE_COMPLEX, (char *) "novel_tracking", sizeof(struct novel_tracking)},
	{NHTYPE_COMPLEX, (char *) "context_info", sizeof(struct context_info)},
	{NHTYPE_COMPLEX, (char *) "nhcoord", sizeof(struct nhcoord)},
	{NHTYPE_COMPLEX, (char *) "dgn_topology", sizeof(struct dgn_topology)},
	{NHTYPE_COMPLEX, (char *) "kinfo", sizeof(struct kinfo)},
	{NHTYPE_COMPLEX, (char *) "mvitals", sizeof(struct mvitals)},
	{NHTYPE_COMPLEX, (char *) "ls_t", sizeof(struct ls_t)},
	{NHTYPE_COMPLEX, (char *) "bubble", sizeof(struct bubble)},
	{NHTYPE_COMPLEX, (char *) "d_flags", sizeof(struct d_flags)},
	{NHTYPE_COMPLEX, (char *) "d_level", sizeof(struct d_level)},
	{NHTYPE_COMPLEX, (char *) "s_level", sizeof(struct s_level)},
	{NHTYPE_COMPLEX, (char *) "stairway", sizeof(struct stairway)},
	{NHTYPE_COMPLEX, (char *) "dest_area", sizeof(struct dest_area)},
	{NHTYPE_COMPLEX, (char *) "dungeon", sizeof(struct dungeon)},
	{NHTYPE_COMPLEX, (char *) "branch", sizeof(struct branch)},
	{NHTYPE_COMPLEX, (char *) "linfo", sizeof(struct linfo)},
	{NHTYPE_COMPLEX, (char *) "mapseen", sizeof(struct mapseen)},
	{NHTYPE_COMPLEX, (char *) "mapseen_feat", sizeof(struct mapseen_feat)},
	{NHTYPE_COMPLEX, (char *) "mapseen_flags", sizeof(struct mapseen_flags)},
	{NHTYPE_COMPLEX, (char *) "mapseen_rooms", sizeof(struct mapseen_rooms)},
	{NHTYPE_COMPLEX, (char *) "engr", sizeof(struct engr)},
	{NHTYPE_COMPLEX, (char *) "flag", sizeof(struct flag)},
	{NHTYPE_COMPLEX, (char *) "version_info", sizeof(struct version_info)},
	{NHTYPE_COMPLEX, (char *) "savefile_info", sizeof(struct savefile_info)},
	{NHTYPE_COMPLEX, (char *) "fakecorridor", sizeof(struct fakecorridor)},
	{NHTYPE_COMPLEX, (char *) "egd", sizeof(struct egd)},
	{NHTYPE_COMPLEX, (char *) "epri", sizeof(struct epri)},
	{NHTYPE_COMPLEX, (char *) "bill_x", sizeof(struct bill_x)},
	{NHTYPE_COMPLEX, (char *) "eshk", sizeof(struct eshk)},
	{NHTYPE_COMPLEX, (char *) "emin", sizeof(struct emin)},
	{NHTYPE_COMPLEX, (char *) "edog", sizeof(struct edog)},
	{NHTYPE_COMPLEX, (char *) "mextra", sizeof(struct mextra)},
	{NHTYPE_COMPLEX, (char *) "mkroom", sizeof(struct mkroom)},
	{NHTYPE_COMPLEX, (char *) "monst", sizeof(struct monst)},
	{NHTYPE_COMPLEX, (char *) "vptrs", sizeof(union vptrs)},
	{NHTYPE_COMPLEX, (char *) "oextra", sizeof(struct oextra)},
	{NHTYPE_COMPLEX, (char *) "obj", sizeof(struct obj)},
	{NHTYPE_COMPLEX, (char *) "objclass", sizeof(struct objclass)},
	{NHTYPE_COMPLEX, (char *) "fruit", sizeof(struct fruit)},
	{NHTYPE_COMPLEX, (char *) "prop", sizeof(struct prop)},
	{NHTYPE_COMPLEX, (char *) "q_score", sizeof(struct q_score)},
	{NHTYPE_COMPLEX, (char *) "nhrect", sizeof(struct nhrect)},
	{NHTYPE_COMPLEX, (char *) "rm", sizeof(struct rm)},
	{NHTYPE_COMPLEX, (char *) "damage", sizeof(struct damage)},
	{NHTYPE_COMPLEX, (char *) "cemetery", sizeof(struct cemetery)},
	{NHTYPE_COMPLEX, (char *) "levelflags", sizeof(struct levelflags)},
	{NHTYPE_COMPLEX, (char *) "skills", sizeof(struct skills)},
	{NHTYPE_COMPLEX, (char *) "spell", sizeof(struct spell)},
	{NHTYPE_COMPLEX, (char *) "fe", sizeof(struct fe)},
	{NHTYPE_COMPLEX, (char *) "vlaunchinfo", sizeof(union vlaunchinfo)},
	{NHTYPE_COMPLEX, (char *) "trap", sizeof(struct trap)},
	{NHTYPE_COMPLEX, (char *) "u_have", sizeof(struct u_have)},
	{NHTYPE_COMPLEX, (char *) "u_event", sizeof(struct u_event)},
	{NHTYPE_COMPLEX, (char *) "u_achieve", sizeof(struct u_achieve)},
	{NHTYPE_COMPLEX, (char *) "u_realtime", sizeof(struct u_realtime)},
	{NHTYPE_COMPLEX, (char *) "u_conduct", sizeof(struct u_conduct)},
	{NHTYPE_COMPLEX, (char *) "u_roleplay", sizeof(struct u_roleplay)},
	{NHTYPE_COMPLEX, (char *) "you", sizeof(struct you)}
};

int nhdatatypes_size()
{
	return SIZE(nhdatatypes);
}

const char *critical_members[] = {
	"struct align:type:aligntyp",
	"struct align:record:int",
	"struct attribs:a:schar",
	"struct bill_x:bo_id:unsigned",
	"struct bill_x:useup:boolean",
	"struct bill_x:price:long",
	"struct bill_x:bquan:long",
	"struct book_info:book:struct obj *",
	"struct book_info:o_id:unsigned",
	"struct book_info:delay:schar",
	"struct branch:next:struct branch *",
	"struct branch:id:int",
	"struct branch:type:int",
	"struct branch:end1:d_level",
	"struct branch:end2:d_level",
	"struct branch:end1_up:boolean",
	"struct bubble:x:xchar",
	"struct bubble:y:xchar",
	"struct bubble:dx:schar",
	"struct bubble:dy:schar",
	"struct bubble:bm:uchar",
	"struct bubble:prev:struct bubble *",
	"struct bubble:next:struct bubble *",
	"struct bubble:cons:struct container *",
	"struct cemetery:next:struct cemetery *",
	"struct cemetery:who:char",
	"struct cemetery:how:char",
	"struct cemetery:when:char",
	"struct cemetery:frpx:schar",
	"struct cemetery:frpy:schar",
	"struct cemetery:bonesknown:boolean",
	"struct context_info:ident:unsigned",
	"struct context_info:no_of_wizards:unsigned",
	"struct context_info:run:unsigned",
	"struct context_info:startingpet_mid:unsigned",
	"struct context_info:current_fruit:int",
	"struct context_info:warnlevel:int",
	"struct context_info:rndencode:int",
	"struct context_info:next_attrib_check:long",
	"struct context_info:stethoscope_move:long",
	"struct context_info:stethoscope_movement:short",
	"struct context_info:travel:boolean",
	"struct context_info:travel1:boolean",
	"struct context_info:forcefight:boolean",
	"struct context_info:nopick:boolean",
	"struct context_info:made_amulet:boolean",
	"struct context_info:mon_moving:boolean",
	"struct context_info:move:boolean",
	"struct context_info:mv:boolean",
	"struct context_info:bypasses:boolean",
	"struct context_info:botl:boolean",
	"struct context_info:botlx:boolean",
	"struct context_info:door_opened:boolean",
	"struct context_info:digging:dig_info",
	"struct context_info:victual:victual_info",
	"struct context_info:tin:tin_info",
	"struct context_info:spbook:book_info",
	"struct context_info:takeoff:takeoff_info",
	"struct context_info:warntype:warntype_info",
	"struct context_info:polearm:polearm_info",
	"struct context_info:objsplit:obj_split",
	"struct context_info:tribute:tribute_info",
	"struct context_info:novel:novel_tracking",
	"struct d_flags:town:Bitfield(town, 1)",
	"struct d_flags:hellish:Bitfield(hellish, 1)",
	"struct d_flags:maze_like:Bitfield(maze_like, 1)",
	"struct d_flags:rogue_like:Bitfield(rogue_like, 1)",
	"struct d_flags:align:Bitfield(align, 3)",
	"struct d_flags:unused:Bitfield(unused, 1)",
	"struct d_level:dnum:xchar",
	"struct d_level:dlevel:xchar",
	"struct damage:next:struct damage *",
	"struct damage:when:long",
	"struct damage:cost:long",
	"struct damage:place:nhcoord",
	"struct damage:typ:schar",
	"struct dest_area:lx:xchar",
	"struct dest_area:ly:xchar",
	"struct dest_area:hx:xchar",
	"struct dest_area:hy:xchar",
	"struct dest_area:nlx:xchar",
	"struct dest_area:nly:xchar",
	"struct dest_area:nhx:xchar",
	"struct dest_area:nhy:xchar",
	"struct dgn_topology:d_oracle_level:d_level",
	"struct dgn_topology:d_bigroom_level:d_level",
	"struct dgn_topology:d_rogue_level:d_level",
	"struct dgn_topology:d_medusa_level:d_level",
	"struct dgn_topology:d_stronghold_level:d_level",
	"struct dgn_topology:d_valley_level:d_level",
	"struct dgn_topology:d_wiz1_level:d_level",
	"struct dgn_topology:d_wiz2_level:d_level",
	"struct dgn_topology:d_wiz3_level:d_level",
	"struct dgn_topology:d_juiblex_level:d_level",
	"struct dgn_topology:d_orcus_level:d_level",
	"struct dgn_topology:d_baalzebub_level:d_level",
	"struct dgn_topology:d_asmodeus_level:d_level",
	"struct dgn_topology:d_portal_level:d_level",
	"struct dgn_topology:d_sanctum_level:d_level",
	"struct dgn_topology:d_earth_level:d_level",
	"struct dgn_topology:d_water_level:d_level",
	"struct dgn_topology:d_fire_level:d_level",
	"struct dgn_topology:d_air_level:d_level",
	"struct dgn_topology:d_astral_level:d_level",
	"struct dgn_topology:d_tower_dnum:xchar",
	"struct dgn_topology:d_sokoban_dnum:xchar",
	"struct dgn_topology:d_mines_dnum:xchar",
	"struct dgn_topology:d_quest_dnum:xchar",
	"struct dgn_topology:d_qstart_level:d_level",
	"struct dgn_topology:d_qlocate_level:d_level",
	"struct dgn_topology:d_nemesis_level:d_level",
	"struct dgn_topology:d_knox_level:d_level",
	"struct dgn_topology:d_mineend_level:d_level",
	"struct dgn_topology:d_sokoend_level:d_level",
	"struct dig_info:effort:int",
	"struct dig_info:level:d_level",
	"struct dig_info:pos:nhcoord",
	"struct dig_info:lastdigtime:long",
	"struct dig_info:down:boolean",
	"struct dig_info:chew:boolean",
	"struct dig_info:warned:boolean",
	"struct dig_info:quiet:boolean",
	"struct dungeon:dname:char",
	"struct dungeon:proto:char",
	"struct dungeon:boneid:char",
	"struct dungeon:flags:d_flags",
	"struct dungeon:entry_lev:xchar",
	"struct dungeon:num_dunlevs:xchar",
	"struct dungeon:dunlev_ureached:xchar",
	"struct dungeon:ledger_start:int",
	"struct dungeon:depth_start:int",
	"struct edog:droptime:long",
	"struct edog:dropdist:unsigned",
	"struct edog:apport:int",
	"struct edog:whistletime:long",
	"struct edog:hungrytime:long",
	"struct edog:ogoal:nhcoord",
	"struct edog:abuse:int",
	"struct edog:revivals:int",
	"struct edog:mhpmax_penalty:int",
	"struct edog:killed_by_u:Bitfield(killed_by_u, 1)",
	"struct egd:fcbeg:int",
	"struct egd:fcend:int",
	"struct egd:vroom:int",
	"struct egd:gdx:xchar",
	"struct egd:gdy:xchar",
	"struct egd:ogx:xchar",
	"struct egd:ogy:xchar",
	"struct egd:gdlevel:d_level",
	"struct egd:warncnt:xchar",
	"struct egd:gddone:Bitfield(gddone, 1)",
	"struct egd:witness:Bitfield(witness, 2)",
	"struct egd:unused:Bitfield(unused, 5)",
	"struct egd:fakecorr:fakecorridor",
	"struct emin:min_align:aligntyp",
	"struct emin:renegade:boolean",
	"struct engr:nxt_engr:struct engr *",
	"struct engr:engr_txt:char *",
	"struct engr:engr_x:xchar",
	"struct engr:engr_y:xchar",
	"struct engr:engr_lth:unsigned",
	"struct engr:engr_time:long",
	"struct engr:engr_type:xchar",
	"struct epri:shralign:aligntyp",
	"struct epri:shroom:schar",
	"struct epri:shrpos:nhcoord",
	"struct epri:shrlevel:d_level",
	"struct epri:intone_time:long",
	"struct epri:enter_time:long",
	"struct epri:hostile_time:long",
	"struct epri:peaceful_time:long",
	"struct eshk:robbed:long",
	"struct eshk:credit:long",
	"struct eshk:debit:long",
	"struct eshk:loan:long",
	"struct eshk:shoptype:int",
	"struct eshk:shoproom:schar",
	"struct eshk:unused:schar",
	"struct eshk:following:boolean",
	"struct eshk:surcharge:boolean",
	"struct eshk:dismiss_kops:boolean",
	"struct eshk:shk:nhcoord",
	"struct eshk:shd:nhcoord",
	"struct eshk:shoplevel:d_level",
	"struct eshk:billct:int",
	"struct eshk:bill:bill_x",
	"struct eshk:bill_p:struct bill_x *",
	"struct eshk:visitct:int",
	"struct eshk:customer:char",
	"struct eshk:shknam:char",
	"struct fakecorridor:fx:xchar",
	"struct fakecorridor:fy:xchar",
	"struct fakecorridor:ftyp:xchar",
	"struct fe:next:struct fe *",
	"struct fe:timeout:long",
	"struct fe:tid:unsigned long",
	"struct fe:kind:short",
	"struct fe:func_index:short",
	"struct fe:arg:any",
	"struct fe:needs_fixup:Bitfield(needs_fixup, 1)",
	"struct flag:acoustics:boolean",
	"struct flag:autodig:boolean",
	"struct flag:autoquiver:boolean",
	"struct flag:autoopen:boolean",
	"struct flag:beginner:boolean",
	"struct flag:biff:boolean",
	"struct flag:bones:boolean",
	"struct flag:confirm:boolean",
	"struct flag:dark_room:boolean",
	"struct flag:debug:boolean",
	"struct flag:end_own:boolean",
	"struct flag:explore:boolean",
	"struct flag:female:boolean",
	"struct flag:friday13:boolean",
	"struct flag:help:boolean",
	"struct flag:ignintr:boolean",
	"struct flag:ins_chkpt:boolean",
	"struct flag:invlet_constant:boolean",
	"struct flag:legacy:boolean",
	"struct flag:lit_corridor:boolean",
	"struct flag:nap:boolean",
	"struct flag:null:boolean",
	"struct flag:p__obsolete:boolean",
	"struct flag:pickup:boolean",
	"struct flag:pickup_thrown:boolean",
	"struct flag:pushweapon:boolean",
	"struct flag:rest_on_space:boolean",
	"struct flag:safe_dog:boolean",
	"struct flag:showexp:boolean",
	"struct flag:showscore:boolean",
	"struct flag:silent:boolean",
	"struct flag:sortpack:boolean",
	"struct flag:sparkle:boolean",
	"struct flag:standout:boolean",
	"struct flag:time:boolean",
	"struct flag:tombstone:boolean",
	"struct flag:verbose:boolean",
	"struct flag:end_top:int",
	"struct flag:end_around:int",
	"struct flag:moonphase:unsigned",
	"struct flag:suppress_alert:unsigned long",
	"struct flag:paranoia_bits:unsigned",
	"struct flag:pickup_burden:int",
	"struct flag:pile_limit:int",
	"struct flag:sortloot:char",
	"struct flag:inv_order:char",
	"struct flag:pickup_types:char",
	"struct flag:end_disclose:char",
	"struct flag:menu_style:char",
	"struct flag:made_fruit:boolean",
	"struct flag:initrole:int",
	"struct flag:initrace:int",
	"struct flag:initgend:int",
	"struct flag:initalign:int",
	"struct flag:randomall:int",
	"struct flag:pantheon:int",
	"struct flag:lootabc:boolean",
	"struct flag:showrace:boolean",
	"struct flag:travelcmd:boolean",
	"struct flag:runmode:int",
	"struct fruit:fname:char",
	"struct fruit:fid:int",
	"struct fruit:nextf:struct fruit *",
	"struct kinfo:next:struct kinfo *",
	"struct kinfo:id:int",
	"struct kinfo:format:int",
	"struct kinfo:name:char",
	"struct levelflags:nfountains:uchar",
	"struct levelflags:nsinks:uchar",
	"struct levelflags:has_shop:Bitfield(has_shop, 1)",
	"struct levelflags:has_vault:Bitfield(has_vault, 1)",
	"struct levelflags:has_zoo:Bitfield(has_zoo, 1)",
	"struct levelflags:has_court:Bitfield(has_court, 1)",
	"struct levelflags:has_morgue:Bitfield(has_morgue, 1)",
	"struct levelflags:has_beehive:Bitfield(has_beehive, 1)",
	"struct levelflags:has_barracks:Bitfield(has_barracks, 1)",
	"struct levelflags:has_temple:Bitfield(has_temple, 1)",
	"struct levelflags:has_swamp:Bitfield(has_swamp, 1)",
	"struct levelflags:noteleport:Bitfield(noteleport, 1)",
	"struct levelflags:hardfloor:Bitfield(hardfloor, 1)",
	"struct levelflags:nommap:Bitfield(nommap, 1)",
	"struct levelflags:hero_memory:Bitfield(hero_memory, 1)",
	"struct levelflags:shortsighted:Bitfield(shortsighted, 1)",
	"struct levelflags:graveyard:Bitfield(graveyard, 1)",
	"struct levelflags:sokoban_rules:Bitfield(sokoban_rules, 1)",
	"struct levelflags:is_maze_lev:Bitfield(is_maze_lev, 1)",
	"struct levelflags:is_cavernous_lev:Bitfield(is_cavernous_lev, 1)",
	"struct levelflags:arboreal:Bitfield(arboreal, 1)",
	"struct levelflags:wizard_bones:Bitfield(wizard_bones, 1)",
	"struct levelflags:corrmaze:Bitfield(corrmaze, 1)",
	"struct linfo:flags:unsigned char",
#ifdef MFLOPPY
	"struct linfo:where:int",
	"struct linfo:time:long",
	"struct linfo:size:long",
#endif /*MFLOPPY*/
	"struct ls_t:next:struct ls_t *",
	"struct ls_t:x:xchar",
	"struct ls_t:y:xchar",
	"struct ls_t:range:short",
	"struct ls_t:flags:short",
	"struct ls_t:type:short",
	"struct ls_t:id:any",
	"struct mapseen_feat:nfount:Bitfield(nfount, 2)",
	"struct mapseen_feat:nsink:Bitfield(nsink, 2)",
	"struct mapseen_feat:naltar:Bitfield(naltar, 2)",
	"struct mapseen_feat:nthrone:Bitfield(nthrone, 2)",
	"struct mapseen_feat:ngrave:Bitfield(ngrave, 2)",
	"struct mapseen_feat:ntree:Bitfield(ntree, 2)",
	"struct mapseen_feat:water:Bitfield(water, 2)",
	"struct mapseen_feat:lava:Bitfield(lava, 2)",
	"struct mapseen_feat:ice:Bitfield(ice, 2)",
	"struct mapseen_feat:nshop:Bitfield(nshop, 2)",
	"struct mapseen_feat:ntemple:Bitfield(ntemple, 2)",
	"struct mapseen_feat:msalign:Bitfield(msalign, 2)",
	"struct mapseen_feat:shoptype:Bitfield(shoptype, 5)",
	"struct mapseen_flags:unreachable:Bitfield(unreachable, 1)",
	"struct mapseen_flags:forgot:Bitfield(forgot, 1)",
	"struct mapseen_flags:knownbones:Bitfield(knownbones, 1)",
	"struct mapseen_flags:oracle:Bitfield(oracle, 1)",
	"struct mapseen_flags:sokosolved:Bitfield(sokosolved, 1)",
	"struct mapseen_flags:bigroom:Bitfield(bigroom, 1)",
	"struct mapseen_flags:castle:Bitfield(castle, 1)",
	"struct mapseen_flags:castletune:Bitfield(castletune, 1)",
	"struct mapseen_flags:valley:Bitfield(valley, 1)",
	"struct mapseen_flags:msanctum:Bitfield(msanctum, 1)",
	"struct mapseen_flags:ludios:Bitfield(ludios, 1)",
	"struct mapseen_flags:roguelevel:Bitfield(roguelevel, 1)",
	"struct mapseen_flags:quest_summons:Bitfield(quest_summons, 1)",
	"struct mapseen_flags:questing:Bitfield(questing, 1)",
	"struct mapseen_flags:vibrating_square:Bitfield(vibrating_square, 1)",
	"struct mapseen_flags:spare1:Bitfield(spare1, 1)",
	"struct mapseen_rooms:seen:Bitfield(seen, 1)",
	"struct mapseen_rooms:untended:Bitfield(untended, 1)",
	"struct mapseen:next:struct mapseen *",
	"struct mapseen:br:branch *",
	"struct mapseen:lev:d_level",
	"struct mapseen:feat:mapseen_feat",
	"struct mapseen:flags:mapseen_flags",
	"struct mapseen:custom:char *",
	"struct mapseen:custom_lth:unsigned",
	"struct mapseen:msrooms:mapseen_rooms",
	"struct mapseen:final_resting_place:struct cemetery *",
	"struct mextra:mname:char *",
	"struct mextra:egd:struct egd *",
	"struct mextra:epri:struct epri *",
	"struct mextra:eshk:struct eshk *",
	"struct mextra:emin:struct emin *",
	"struct mextra:edog:struct edog *",
	"struct mextra:mcorpsenm:int",
	"struct mkroom:lx:schar",
	"struct mkroom:hx:schar",
	"struct mkroom:ly:schar",
	"struct mkroom:hy:schar",
	"struct mkroom:rtype:schar",
	"struct mkroom:orig_rtype:schar",
	"struct mkroom:rlit:schar",
	"struct mkroom:needfill:schar",
	"struct mkroom:needjoining:schar",
	"struct mkroom:doorct:schar",
	"struct mkroom:fdoor:schar",
	"struct mkroom:nsubrooms:schar",
	"struct mkroom:irregular:boolean",
	"struct mkroom:sbrooms:struct mkroom *",
	"struct mkroom:resident:struct monst *",
	"struct monst:nmon:struct monst *",
	"struct monst:data:struct permonst *",
	"struct monst:m_id:unsigned",
	"struct monst:mnum:short",
	"struct monst:cham:short",
	"struct monst:movement:short",
	"struct monst:m_lev:uchar",
	"struct monst:malign:aligntyp",
	"struct monst:mx:xchar",
	"struct monst:my:xchar",
	"struct monst:mux:xchar",
	"struct monst:muy:xchar",
	"struct monst:mtrack:nhcoord",
	"struct monst:mhp:int",
	"struct monst:mhpmax:int",
	"struct monst:mappearance:unsigned",
	"struct monst:m_ap_type:uchar",
	"struct monst:mtame:schar",
	"struct monst:mextrinsics:unsigned short",
	"struct monst:mspec_used:int",
	"struct monst:female:Bitfield(female, 1)",
	"struct monst:minvis:Bitfield(minvis, 1)",
	"struct monst:invis_blkd:Bitfield(invis_blkd, 1)",
	"struct monst:perminvis:Bitfield(perminvis, 1)",
	"struct monst:mcan:Bitfield(mcan, 1)",
	"struct monst:mburied:Bitfield(mburied, 1)",
	"struct monst:mundetected:Bitfield(mundetected, 1)",
	"struct monst:mcansee:Bitfield(mcansee, 1)",
	"struct monst:mspeed:Bitfield(mspeed, 2)",
	"struct monst:permspeed:Bitfield(permspeed, 2)",
	"struct monst:mrevived:Bitfield(mrevived, 1)",
	"struct monst:mcloned:Bitfield(mcloned, 1)",
	"struct monst:mavenge:Bitfield(mavenge, 1)",
	"struct monst:mflee:Bitfield(mflee, 1)",
	"struct monst:mfleetim:Bitfield(mfleetim, 7)",
	"struct monst:msleeping:Bitfield(msleeping, 1)",
	"struct monst:mblinded:Bitfield(mblinded, 7)",
	"struct monst:mstun:Bitfield(mstun, 1)",
	"struct monst:mfrozen:Bitfield(mfrozen, 7)",
	"struct monst:mcanmove:Bitfield(mcanmove, 1)",
	"struct monst:mconf:Bitfield(mconf, 1)",
	"struct monst:mpeaceful:Bitfield(mpeaceful, 1)",
	"struct monst:mtrapped:Bitfield(mtrapped, 1)",
	"struct monst:mleashed:Bitfield(mleashed, 1)",
	"struct monst:isshk:Bitfield(isshk, 1)",
	"struct monst:isminion:Bitfield(isminion, 1)",
	"struct monst:isgd:Bitfield(isgd, 1)",
	"struct monst:ispriest:Bitfield(ispriest, 1)",
	"struct monst:iswiz:Bitfield(iswiz, 1)",
	"struct monst:wormno:Bitfield(wormno, 5)",
	"struct monst:mtemplit:Bitfield(mtemplit, 1)",
	"struct monst:mstrategy:unsigned long",
	"struct monst:mtrapseen:long",
	"struct monst:mlstmv:long",
	"struct monst:mstate:long",
	"struct monst:migflags:long",
	"struct monst:mspare1:long",
	"struct monst:minvent:struct obj *",
	"struct monst:mw:struct obj *",
	"struct monst:misc_worn_check:long",
	"struct monst:weapon_check:xchar",
	"struct monst:meating:int",
	"struct monst:mextra:struct mextra *",
	"struct mvitals:born:uchar",
	"struct mvitals:died:uchar",
	"struct mvitals:mvflags:uchar",
	"struct nhcoord:x:xchar",
	"struct nhcoord:y:xchar",
	"struct nhrect:lx:xchar",
	"struct nhrect:ly:xchar",
	"struct nhrect:hx:xchar",
	"struct nhrect:hy:xchar",
	"struct novel_tracking:id:unsigned",
	"struct novel_tracking:count:int",
	"struct novel_tracking:pasg:xchar",
	"struct obj:nobj:struct obj *",
	"struct obj:v:vptrs",
	"struct obj:cobj:struct obj *",
	"struct obj:o_id:unsigned",
	"struct obj:ox:xchar",
	"struct obj:oy:xchar",
	"struct obj:otyp:short",
	"struct obj:owt:unsigned",
	"struct obj:quan:long",
	"struct obj:spe:schar",
	"struct obj:oclass:char",
	"struct obj:invlet:char",
	"struct obj:oartifact:char",
	"struct obj:where:xchar",
	"struct obj:timed:xchar",
	"struct obj:cursed:Bitfield(cursed, 1)",
	"struct obj:blessed:Bitfield(blessed, 1)",
	"struct obj:unpaid:Bitfield(unpaid, 1)",
	"struct obj:no_charge:Bitfield(no_charge, 1)",
	"struct obj:known:Bitfield(known, 1)",
	"struct obj:dknown:Bitfield(dknown, 1)",
	"struct obj:bknown:Bitfield(bknown, 1)",
	"struct obj:rknown:Bitfield(rknown, 1)",
	"struct obj:oeroded:Bitfield(oeroded, 2)",
	"struct obj:oeroded2:Bitfield(oeroded2, 2)",
	"struct obj:oerodeproof:Bitfield(oerodeproof, 1)",
	"struct obj:olocked:Bitfield(olocked, 1)",
	"struct obj:obroken:Bitfield(obroken, 1)",
	"struct obj:otrapped:Bitfield(otrapped, 1)",
	"struct obj:recharged:Bitfield(recharged, 3)",
	"struct obj:lamplit:Bitfield(lamplit, 1)",
	"struct obj:globby:Bitfield(globby, 1)",
	"struct obj:greased:Bitfield(greased, 1)",
	"struct obj:nomerge:Bitfield(nomerge, 1)",
	"struct obj:was_thrown:Bitfield(was_thrown, 1)",
	"struct obj:in_use:Bitfield(in_use, 1)",
	"struct obj:bypass:Bitfield(bypass, 1)",
	"struct obj:cknown:Bitfield(cknown, 1)",
	"struct obj:lknown:Bitfield(lknown, 1)",
	"struct obj:corpsenm:int",
	"struct obj:usecount:int",
	"struct obj:oeaten:unsigned",
	"struct obj:age:long",
	"struct obj:owornmask:long",
	"struct obj:oextra:struct oextra *",
	"struct objclass:oc_name_idx:short",
	"struct objclass:oc_descr_idx:short",
	"struct objclass:oc_uname:char *",
	"struct objclass:oc_name_known:Bitfield(oc_name_known, 1)",
	"struct objclass:oc_merge:Bitfield(oc_merge, 1)",
	"struct objclass:oc_uses_known:Bitfield(oc_uses_known, 1)",
	"struct objclass:oc_pre_discovered:Bitfield(oc_pre_discovered, 1)",
	"struct objclass:oc_magic:Bitfield(oc_magic, 1)",
	"struct objclass:oc_charged:Bitfield(oc_charged, 1)",
	"struct objclass:oc_unique:Bitfield(oc_unique, 1)",
	"struct objclass:oc_nowish:Bitfield(oc_nowish, 1)",
	"struct objclass:oc_big:Bitfield(oc_big, 1)",
	"struct objclass:oc_tough:Bitfield(oc_tough, 1)",
	"struct objclass:oc_dir:Bitfield(oc_dir, 2)",
	"struct objclass:oc_material:Bitfield(oc_material, 5)",
	"struct objclass:oc_subtyp:schar",
	"struct objclass:oc_oprop:uchar",
	"struct objclass:oc_class:char",
	"struct objclass:oc_delay:schar",
	"struct objclass:oc_color:uchar",
	"struct objclass:oc_prob:short",
	"struct objclass:oc_weight:unsigned short",
	"struct objclass:oc_cost:short",
	"struct objclass:oc_wsdam:schar",
	"struct objclass:oc_wldam:schar",
	"struct objclass:oc_oc1:schar",
	"struct objclass:oc_oc2:schar",
	"struct objclass:oc_nutrition:unsigned short",
	"struct obj_split:parent_oid:unsigned",
	"struct obj_split:child_oid:unsigned",
	"struct oextra:oname:char *",
	"struct oextra:omonst:struct monst *",
	"struct oextra:omid:unsigned *",
	"struct oextra:olong:long *",
	"struct oextra:omailcmd:char *",
	"struct polearm_info:hitmon:struct monst *",
	"struct polearm_info:m_id:unsigned",
	"struct prop:extrinsic:long",
	"struct prop:blocked:long",
	"struct prop:intrinsic:long",
	"struct q_score:first_start:Bitfield(first_start, 1)",
	"struct q_score:met_leader:Bitfield(met_leader, 1)",
	"struct q_score:not_ready:Bitfield(not_ready, 3)",
	"struct q_score:pissed_off:Bitfield(pissed_off, 1)",
	"struct q_score:got_quest:Bitfield(got_quest, 1)",
	"struct q_score:first_locate:Bitfield(first_locate, 1)",
	"struct q_score:met_intermed:Bitfield(met_intermed, 1)",
	"struct q_score:got_final:Bitfield(got_final, 1)",
	"struct q_score:made_goal:Bitfield(made_goal, 3)",
	"struct q_score:met_nemesis:Bitfield(met_nemesis, 1)",
	"struct q_score:killed_nemesis:Bitfield(killed_nemesis, 1)",
	"struct q_score:in_battle:Bitfield(in_battle, 1)",
	"struct q_score:cheater:Bitfield(cheater, 1)",
	"struct q_score:touched_artifact:Bitfield(touched_artifact, 1)",
	"struct q_score:offered_artifact:Bitfield(offered_artifact, 1)",
	"struct q_score:got_thanks:Bitfield(got_thanks, 1)",
	"struct q_score:ldrgend:Bitfield(ldrgend, 2)",
	"struct q_score:nemgend:Bitfield(nemgend, 2)",
	"struct q_score:godgend:Bitfield(godgend, 2)",
	"struct q_score:leader_is_dead:Bitfield(leader_is_dead, 1)",
	"struct q_score:leader_m_id:unsigned",
	"struct rm:glyph:int",
	"struct rm:typ:schar",
	"struct rm:seenv:uchar",
	"struct rm:flags:Bitfield(flags, 5)",
	"struct rm:horizontal:Bitfield(horizontal, 1)",
	"struct rm:lit:Bitfield(lit, 1)",
	"struct rm:waslit:Bitfield(waslit, 1)",
	"struct rm:roomno:Bitfield(roomno, 6)",
	"struct rm:edge:Bitfield(edge, 1)",
	"struct rm:candig:Bitfield(candig, 1)",
	"struct s_level:next:struct s_level *",
	"struct s_level:dlevel:d_level",
	"struct s_level:proto:char",
	"struct s_level:boneid:char",
	"struct s_level:rndlevs:uchar",
	"struct s_level:flags:d_flags",
	"struct savefile_info:sfi1:unsigned long",
	"struct savefile_info:sfi2:unsigned long",
	"struct savefile_info:sfi3:unsigned long",
	"struct skills:skill:xchar",
	"struct skills:max_skill:xchar",
	"struct skills:advance:unsigned short",
	"struct spell:sp_id:short",
	"struct spell:sp_lev:xchar",
	"struct spell:sp_know:int",
	"struct stairway:sx:xchar",
	"struct stairway:sy:xchar",
	"struct stairway:tolev:d_level",
	"struct stairway:up:char",
	"struct takeoff_info:mask:long",
	"struct takeoff_info:what:long",
	"struct takeoff_info:delay:int",
	"struct takeoff_info:cancelled_don:boolean",
	"struct takeoff_info:disrobing:char",
	"struct tin_info:tin:struct obj *",
	"struct tin_info:o_id:unsigned",
	"struct tin_info:usedtime:int",
	"struct tin_info:reqtime:int",
	"struct trap:ntrap:struct trap *",
	"struct trap:tx:xchar",
	"struct trap:ty:xchar",
	"struct trap:dst:d_level",
	"struct trap:launch:nhcoord",
	"struct trap:ttyp:Bitfield(ttyp, 5)",
	"struct trap:tseen:Bitfield(tseen, 1)",
	"struct trap:once:Bitfield(once, 1)",
	"struct trap:madeby_u:Bitfield(madeby_u, 1)",
	"struct trap:vl:vlaunchinfo",
	"struct tribute_info:tributesz:size_t",
	"struct tribute_info:enabled:boolean",
	"struct tribute_info:bookstock:Bitfield(bookstock, 1)",
	"struct tribute_info:Deathnotice:Bitfield(Deathnotice,1)",
	"struct u_achieve:amulet:Bitfield(amulet, 1)",
	"struct u_achieve:bell:Bitfield(bell, 1)",
	"struct u_achieve:book:Bitfield(book, 1)",
	"struct u_achieve:menorah:Bitfield(menorah, 1)",
	"struct u_achieve:enter_gehennom:Bitfield(enter_gehennom,1)",
	"struct u_achieve:ascended:Bitfield(ascended, 1)",
	"struct u_achieve:mines_luckstone:Bitfield(mines_luckstone, 1)",
	"struct u_achieve:finish_sokoban:Bitfield(finish_sokoban, 1)",
	"struct u_achieve:killed_medusa:Bitfield(killed_medusa, 1)",
	"struct u_conduct:unvegetarian:long",
	"struct u_conduct:unvegan:long",
	"struct u_conduct:food:long",
	"struct u_conduct:gnostic:long",
	"struct u_conduct:weaphit:long",
	"struct u_conduct:killer:long",
	"struct u_conduct:literate:long",
	"struct u_conduct:polypiles:long",
	"struct u_conduct:polyselfs:long",
	"struct u_conduct:wishes:long",
	"struct u_conduct:wisharti:long",
	"struct u_event:minor_oracle:Bitfield(minor_oracle, 1)",
	"struct u_event:major_oracle:Bitfield(major_oracle, 1)",
	"struct u_event:read_tribute:Bitfield(read_tribute, 1)",
	"struct u_event:qcalled:Bitfield(qcalled, 1)",
	"struct u_event:qexpelled:Bitfield(qexpelled, 1)",
	"struct u_event:qcompleted:Bitfield(qcompleted, 1)",
	"struct u_event:uheard_tune:Bitfield(uheard_tune, 2)",
	"struct u_event:uopened_dbridge:Bitfield(uopened_dbridge, 1)",
	"struct u_event:invoked:Bitfield(invoked, 1)",
	"struct u_event:gehennom_entered:Bitfield(gehennom_entered, 1)",
	"struct u_event:uhand_of_elbereth:Bitfield(uhand_of_elbereth, 2)",
	"struct u_event:udemigod:Bitfield(udemigod, 1)",
	"struct u_event:uvibrated:Bitfield(uvibrated, 1)",
	"struct u_event:ascended:Bitfield(ascended, 1)",
	"struct u_have:amulet:Bitfield(amulet, 1)",
	"struct u_have:bell:Bitfield(bell, 1)",
	"struct u_have:book:Bitfield(book, 1)",
	"struct u_have:menorah:Bitfield(menorah, 1)",
	"struct u_have:questart:Bitfield(questart, 1)",
	"struct u_have:unused:Bitfield(unused, 3)",
	"struct u_realtime:realtime:long",
	"struct u_realtime:start_timing:time_t",
	"struct u_realtime:finish_time:time_t",
	"struct u_roleplay:blind:boolean",
	"struct u_roleplay:nudist:boolean",
	"struct u_roleplay:numbones:long",
	"struct version_info:incarnation:unsigned long",
	"struct version_info:feature_set:unsigned long",
	"struct version_info:entity_count:unsigned long",
	"struct version_info:struct_sizes1:unsigned long",
	"struct version_info:struct_sizes2:unsigned long",
	"struct victual_info:piece:struct obj *",
	"struct victual_info:o_id:unsigned",
	"struct victual_info:usedtime:int",
	"struct victual_info:reqtime:int",
	"struct victual_info:nmod:int",
	"struct victual_info:canchoke:Bitfield(canchoke, 1)",
	"struct victual_info:fullwarn:Bitfield(fullwarn, 1)",
	"struct victual_info:eating:Bitfield(eating, 1)",
	"struct victual_info:doreset:Bitfield(doreset, 1)",
	"union vlaunchinfo:v_launch_otyp:short",
	"union vlaunchinfo:v_launch2:nhcoord",
	"union vlaunchinfo:v_conjoined:uchar",
	"union vlaunchinfo:v_tnote:short",
	"union vptrs:v_nexthere:struct obj *",
	"union vptrs:v_ocontainer:struct obj *",
	"union vptrs:v_ocarry:struct monst *",
	"struct warntype_info:obj:unsigned long",
	"struct warntype_info:polyd:unsigned long",
	"struct warntype_info:species:struct permonst *",
	"struct warntype_info:speciesidx:short",
	"struct you:ux:xchar",
	"struct you:uy:xchar",
	"struct you:dx:schar",
	"struct you:dy:schar",
	"struct you:dz:schar",
	"struct you:di:schar",
	"struct you:tx:xchar",
	"struct you:ty:xchar",
	"struct you:ux0:xchar",
	"struct you:uy0:xchar",
	"struct you:uz:d_level",
	"struct you:uz0:d_level",
	"struct you:utolev:d_level",
	"struct you:utotype:uchar",
	"struct you:umoved:boolean",
	"struct you:last_str_turn:int",
	"struct you:ulevel:int",
	"struct you:ulevelmax:int",
	"struct you:utrap:unsigned",
	"struct you:utraptype:unsigned",
	"struct you:urooms:char",
	"struct you:urooms0:char",
	"struct you:uentered:char",
	"struct you:ushops:char",
	"struct you:ushops0:char",
	"struct you:ushops_entered:char",
	"struct you:ushops_left:char",
	"struct you:uhunger:int",
	"struct you:uhs:unsigned",
	"struct you:uprops:prop",
	"struct you:umconf:unsigned",
	"struct you:usick_type:Bitfield(usick_type, 2)",
	"struct you:nv_range:int",
	"struct you:xray_range:int",
	"struct you:bglyph:int",
	"struct you:cglyph:int",
	"struct you:bc_order:int",
	"struct you:bc_felt:int",
	"struct you:umonster:int",
	"struct you:umonnum:int",
	"struct you:mh:int",
	"struct you:mhmax:int",
	"struct you:mtimedone:int",
	"struct you:macurr:attribs",
	"struct you:mamax:attribs",
	"struct you:ulycn:int",
	"struct you:ucreamed:unsigned",
	"struct you:uswldtim:unsigned",
	"struct you:uswallow:Bitfield(uswallow, 1)",
	"struct you:uinwater:Bitfield(uinwater, 1)",
	"struct you:uundetected:Bitfield(uundetected, 1)",
	"struct you:mfemale:Bitfield(mfemale, 1)",
	"struct you:uinvulnerable:Bitfield(uinvulnerable, 1)",
	"struct you:uburied:Bitfield(uburied, 1)",
	"struct you:uedibility:Bitfield(uedibility, 1)",
	"struct you:udg_cnt:unsigned",
	"struct you:uachieve:u_achieve",
	"struct you:uevent:u_event",
	"struct you:uhave:u_have",
	"struct you:uconduct:u_conduct",
	"struct you:uroleplay:u_roleplay",
	"struct you:acurr:attribs",
	"struct you:aexe:attribs",
	"struct you:abon:attribs",
	"struct you:amax:attribs",
	"struct you:atemp:attribs",
	"struct you:atime:attribs",
	"struct you:ualign:align",
	"struct you:ualignbase:aligntyp",
	"struct you:uluck:schar",
	"struct you:moreluck:schar",
	"struct you:uhitinc:schar",
	"struct you:udaminc:schar",
	"struct you:uac:schar",
	"struct you:uspellprot:uchar",
	"struct you:usptime:uchar",
	"struct you:uspmtime:uchar",
	"struct you:uhp:int",
	"struct you:uhpmax:int",
	"struct you:uen:int",
	"struct you:uenmax:int",
	"struct you:uhpinc:xchar",
	"struct you:ueninc:xchar",
	"struct you:ugangr:int",
	"struct you:ugifts:int",
	"struct you:ublessed:int",
	"struct you:ublesscnt:int",
	"struct you:umoney0:long",
	"struct you:uspare1:long",
	"struct you:uexp:long",
	"struct you:urexp:long",
	"struct you:ucleansed:long",
	"struct you:usleep:long",
	"struct you:uinvault:int",
	"struct you:ustuck:struct monst *",
	"struct you:usteed:struct monst *",
	"struct you:ugallop:long",
	"struct you:urideturns:int",
	"struct you:umortality:int",
	"struct you:ugrave_arise:int",
	"struct you:weapon_slots:int",
	"struct you:skills_advanced:int",
	"struct you:skill_record:xchar",
	"struct you:weapon_skills:skills",
	"struct you:twoweap:boolean",
	"struct you:mcham:short",
};

int critical_members_count()
{
	return SIZE(critical_members);
}

/*sfdata.c*/
